#!/usr/bin/env python3
"""
Emergency Bypass Manager
Manages emergency deployment bypasses with proper authorization and audit trails.
"""

import hashlib
import json
import logging
import os
import secrets
import subprocess
import sys
from dataclasses import dataclass
from datetime import datetime, timedelta
from pathlib import Path
from typing import Dict, List, Optional, Tuple

import yaml

# Configure logging
logging.basicConfig(level=logging.INFO, format="%(asctime)s - %(levelname)s - %(message)s")
logger = logging.getLogger(__name__)


@dataclass
class BypassRequest:
    scenario: str
    requestor: str
    approver: str
    duration_hours: int
    commit_sha: str
    justification: str
    token: str
    timestamp: str


@dataclass
class BypassToken:
    token: str
    scenario: str
    issued_by: str
    expires_at: str
    single_use: bool
    used: bool


class EmergencyBypassManager:
    """Manages emergency deployment bypasses with security controls."""

    def __init__(self, config_path: str = "config/security/emergency-procedures.yaml"):
        self.config_path = Path(config_path)
        self.config = self._load_config()
        self.bypass_log = Path("logs/emergency-bypasses.json")
        self.bypass_log.parent.mkdir(parents=True, exist_ok=True)

    def _load_config(self) -> Dict:
        """Load emergency procedures configuration."""
        try:
            if self.config_path.exists():
                with open(self.config_path, "r") as f:
                    return yaml.safe_load(f)
            else:
                logger.warning("Emergency procedures config not found, using defaults")
                return self._default_config()
        except Exception as e:
            logger.error(f"Error loading config: {e}")
            return self._default_config()

    def _default_config(self) -> Dict:
        """Default emergency procedures configuration."""
        return {
            "emergency_procedures": {
                "bypass": {
                    "enabled": True,
                    "requires_approval": True,
                    "token_validation": {"enabled": True},
                    "allowed_scenarios": ["critical_security_patch", "production_outage"],
                },
                "monitoring": {"enhanced_monitoring": True},
            }
        }

    def generate_bypass_token(self, scenario: str, issued_by: str, duration_hours: int = 2) -> str:
        """Generate a secure bypass token."""
        if not self._is_valid_scenario(scenario):
            raise ValueError(f"Invalid bypass scenario: {scenario}")

        # Generate secure token
        token_data = {
            "scenario": scenario,
            "issued_by": issued_by,
            "timestamp": datetime.now().isoformat(),
            "duration_hours": duration_hours,
            "nonce": secrets.token_hex(16),
        }

        # Create token string
        token_string = json.dumps(token_data, sort_keys=True)
        token_hash = hashlib.sha256(token_string.encode()).hexdigest()

        # Create bypass token
        bypass_token = BypassToken(
            token=token_hash[:32],  # Use first 32 chars of hash
            scenario=scenario,
            issued_by=issued_by,
            expires_at=(datetime.now() + timedelta(hours=duration_hours)).isoformat(),
            single_use=True,
            used=False,
        )

        # Store token
        self._store_token(bypass_token)

        logger.info(f"Generated bypass token for scenario '{scenario}' by {issued_by}")
        return bypass_token.token

    def validate_bypass_token(self, token: str, scenario: str) -> Tuple[bool, str]:
        """Validate a bypass token."""
        try:
            stored_token = self._retrieve_token(token)

            if not stored_token:
                return False, "Invalid token"

            if stored_token.used and stored_token.single_use:
                return False, "Token already used"

            if datetime.fromisoformat(stored_token.expires_at) < datetime.now():
                return False, "Token expired"

            if stored_token.scenario != scenario:
                return False, f"Token scenario mismatch: expected {scenario}, got {stored_token.scenario}"

            # Mark token as used if single use
            if stored_token.single_use:
                stored_token.used = True
                self._update_token(stored_token)

            return True, "Token valid"

        except Exception as e:
            logger.error(f"Error validating token: {e}")
            return False, f"Token validation error: {e}"

    def request_emergency_bypass(
        self, scenario: str, requestor: str, justification: str, commit_sha: str, token: Optional[str] = None
    ) -> Tuple[bool, str]:
        """Request emergency bypass with proper authorization."""

        # Check if bypasses are enabled
        if not self.config.get("emergency_procedures", {}).get("bypass", {}).get("enabled", False):
            return False, "Emergency bypasses are disabled"

        # Validate scenario
        if not self._is_valid_scenario(scenario):
            return False, f"Invalid bypass scenario: {scenario}"

        # Check if token validation is required
        token_config = self.config.get("emergency_procedures", {}).get("bypass", {}).get("token_validation", {})
        if token_config.get("enabled", True) and not token:
            return False, "Bypass token required but not provided"

        # Validate token if provided
        if token:
            valid, message = self.validate_bypass_token(token, scenario)
            if not valid:
                return False, f"Token validation failed: {message}"

        # Create bypass request
        bypass_request = BypassRequest(
            scenario=scenario,
            requestor=requestor,
            approver=requestor,  # In automated context
            duration_hours=self._get_max_duration(scenario),
            commit_sha=commit_sha,
            justification=justification,
            token=token or "none",
            timestamp=datetime.now().isoformat(),
        )

        # Log bypass request
        self._log_bypass_request(bypass_request)

        # Send notifications
        self._send_bypass_notifications(bypass_request)

        # Enable enhanced monitoring
        self._enable_enhanced_monitoring(bypass_request)

        logger.warning(f"Emergency bypass APPROVED for scenario '{scenario}' by {requestor}")
        return True, "Emergency bypass approved"

    def check_bypass_status(self, commit_sha: str) -> Tuple[bool, Optional[BypassRequest]]:
        """Check if a commit has an active bypass."""
        try:
            if not self.bypass_log.exists():
                return False, None

            with open(self.bypass_log, "r") as f:
                bypass_entries = [json.loads(line) for line in f]

            # Find matching bypass
            for entry in reversed(bypass_entries):  # Check newest first
                if entry.get("commit_sha") == commit_sha:
                    bypass_request = BypassRequest(**entry)

                    # Check if bypass is still valid
                    created_time = datetime.fromisoformat(bypass_request.timestamp)
                    expiry_time = created_time + timedelta(hours=bypass_request.duration_hours)

                    if datetime.now() < expiry_time:
                        return True, bypass_request
                    else:
                        logger.info(f"Bypass for {commit_sha} has expired")
                        return False, bypass_request

            return False, None

        except Exception as e:
            logger.error(f"Error checking bypass status: {e}")
            return False, None

    def _is_valid_scenario(self, scenario: str) -> bool:
        """Check if scenario is allowed."""
        allowed_scenarios = self.config.get("emergency_procedures", {}).get("bypass", {}).get("allowed_scenarios", [])
        return scenario in allowed_scenarios

    def _get_max_duration(self, scenario: str) -> int:
        """Get maximum duration for a scenario."""
        restrictions = self.config.get("emergency_procedures", {}).get("bypass", {}).get("restrictions", {})
        return restrictions.get("max_duration_hours", 8)

    def _store_token(self, token: BypassToken):
        """Store bypass token securely."""
        tokens_file = Path("logs/bypass-tokens.json")
        tokens_file.parent.mkdir(parents=True, exist_ok=True)

        # Read existing tokens
        tokens = []
        if tokens_file.exists():
            try:
                with open(tokens_file, "r") as f:
                    tokens = json.load(f)
            except Exception:
                tokens = []

        # Add new token
        tokens.append(
            {
                "token": token.token,
                "scenario": token.scenario,
                "issued_by": token.issued_by,
                "expires_at": token.expires_at,
                "single_use": token.single_use,
                "used": token.used,
            }
        )

        # Write back
        with open(tokens_file, "w") as f:
            json.dump(tokens, f, indent=2)

    def _retrieve_token(self, token: str) -> Optional[BypassToken]:
        """Retrieve stored token."""
        tokens_file = Path("logs/bypass-tokens.json")

        if not tokens_file.exists():
            return None

        try:
            with open(tokens_file, "r") as f:
                tokens = json.load(f)

            for token_data in tokens:
                if token_data["token"] == token:
                    return BypassToken(**token_data)

            return None

        except Exception as e:
            logger.error(f"Error retrieving token: {e}")
            return None

    def _update_token(self, token: BypassToken):
        """Update stored token."""
        tokens_file = Path("logs/bypass-tokens.json")

        if not tokens_file.exists():
            return

        try:
            with open(tokens_file, "r") as f:
                tokens = json.load(f)

            # Update matching token
            for token_data in tokens:
                if token_data["token"] == token.token:
                    token_data["used"] = token.used
                    break

            with open(tokens_file, "w") as f:
                json.dump(tokens, f, indent=2)

        except Exception as e:
            logger.error(f"Error updating token: {e}")

    def _log_bypass_request(self, request: BypassRequest):
        """Log bypass request for audit purposes."""
        log_entry = {
            "scenario": request.scenario,
            "requestor": request.requestor,
            "approver": request.approver,
            "duration_hours": request.duration_hours,
            "commit_sha": request.commit_sha,
            "justification": request.justification,
            "token": request.token,
            "timestamp": request.timestamp,
        }

        # Append to bypass log
        with open(self.bypass_log, "a") as f:
            f.write(json.dumps(log_entry) + "\\n")

        logger.info(f"Logged bypass request for {request.commit_sha}")

    def _send_bypass_notifications(self, request: BypassRequest):
        """Send bypass notifications to stakeholders."""
        try:
            # In a real implementation, this would send notifications via:
            # - Slack
            # - Email
            # - PagerDuty
            # - etc.

            notification_message = f"""
            EMERGENCY DEPLOYMENT BYPASS ACTIVATED

            Scenario: {request.scenario}
            Requestor: {request.requestor}
            Commit: {request.commit_sha}
            Duration: {request.duration_hours} hours
            Justification: {request.justification}

            Enhanced monitoring is now active.
            Post-incident review required.
            """

            logger.warning(f"BYPASS NOTIFICATION: {notification_message.strip()}")

            # Write notification to file for CI/CD pickup
            notification_file = Path("logs/bypass-notifications.json")
            notification_file.parent.mkdir(parents=True, exist_ok=True)

            notification_data = {
                "type": "emergency_bypass",
                "scenario": request.scenario,
                "requestor": request.requestor,
                "commit_sha": request.commit_sha,
                "timestamp": request.timestamp,
                "message": notification_message.strip(),
            }

            with open(notification_file, "w") as f:
                json.dump(notification_data, f, indent=2)

        except Exception as e:
            logger.error(f"Error sending notifications: {e}")

    def _enable_enhanced_monitoring(self, request: BypassRequest):
        """Enable enhanced monitoring during bypass."""
        try:
            monitoring_config = {
                "enhanced_monitoring": True,
                "bypass_scenario": request.scenario,
                "commit_sha": request.commit_sha,
                "start_time": request.timestamp,
                "duration_hours": request.duration_hours,
                "monitoring_thresholds": self.config.get("emergency_procedures", {})
                .get("monitoring", {})
                .get("thresholds", {}),
            }

            monitoring_file = Path("logs/enhanced-monitoring.json")
            monitoring_file.parent.mkdir(parents=True, exist_ok=True)

            with open(monitoring_file, "w") as f:
                json.dump(monitoring_config, f, indent=2)

            logger.info(f"Enhanced monitoring enabled for bypass {request.commit_sha}")

        except Exception as e:
            logger.error(f"Error enabling enhanced monitoring: {e}")


def main():
    import argparse

    parser = argparse.ArgumentParser(description="Emergency Bypass Manager")
    parser.add_argument("action", choices=["generate-token", "validate-token", "request-bypass", "check-status"])
    parser.add_argument("--scenario", help="Bypass scenario")
    parser.add_argument("--requestor", help="Person requesting bypass")
    parser.add_argument("--token", help="Bypass token")
    parser.add_argument("--justification", help="Justification for bypass")
    parser.add_argument("--commit-sha", help="Commit SHA")
    parser.add_argument("--duration", type=int, default=2, help="Duration in hours")

    args = parser.parse_args()

    manager = EmergencyBypassManager()

    if args.action == "generate-token":
        if not args.scenario or not args.requestor:
            print("Error: --scenario and --requestor required for token generation")
            sys.exit(1)

        try:
            token = manager.generate_bypass_token(args.scenario, args.requestor, args.duration)
            print(f"Generated bypass token: {token}")
            print(f"Expires in {args.duration} hours")
        except Exception as e:
            print(f"Error generating token: {e}")
            sys.exit(1)

    elif args.action == "validate-token":
        if not args.token or not args.scenario:
            print("Error: --token and --scenario required for validation")
            sys.exit(1)

        valid, message = manager.validate_bypass_token(args.token, args.scenario)
        print(f"Token validation: {message}")
        sys.exit(0 if valid else 1)

    elif args.action == "request-bypass":
        if not all([args.scenario, args.requestor, args.justification, args.commit_sha]):
            print("Error: --scenario, --requestor, --justification, and --commit-sha required")
            sys.exit(1)

        approved, message = manager.request_emergency_bypass(
            args.scenario, args.requestor, args.justification, args.commit_sha, args.token
        )
        print(f"Bypass request: {message}")
        sys.exit(0 if approved else 1)

    elif args.action == "check-status":
        if not args.commit_sha:
            print("Error: --commit-sha required for status check")
            sys.exit(1)

        active, bypass_request = manager.check_bypass_status(args.commit_sha)
        if active and bypass_request:
            print(f"Active bypass found for {args.commit_sha}")
            print(f"Scenario: {bypass_request.scenario}")
            print(f"Requestor: {bypass_request.requestor}")
            print(f"Duration: {bypass_request.duration_hours} hours")
            print(f"Started: {bypass_request.timestamp}")
        else:
            print(f"No active bypass for {args.commit_sha}")

        sys.exit(0 if active else 1)


if __name__ == "__main__":
    main()
