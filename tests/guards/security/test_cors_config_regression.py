#!/usr/bin/env python3
"""
CORS Configuration Regression Guard Tests
========================================

Prevents regression in secure CORS configuration implementation.
Validates environment-specific origins and security headers.

Generated by TDD London School Swarm Agent for Phase 5 guard protection.
"""

import pytest
import os
from unittest.mock import patch, MagicMock
from typing import List, Dict, Any

# Test the CORS configuration module
import sys
sys.path.insert(0, "src")

from src.security.cors_config import (
    get_secure_cors_origins,
    get_admin_cors_origins, 
    get_websocket_cors_origins,
    SECURE_CORS_CONFIG,
    ADMIN_CORS_CONFIG,
    WEBSOCKET_CORS_CONFIG
)


class TestCORSConfigurationRegression:
    """Regression tests for CORS configuration security fixes."""
    
    @pytest.fixture(autouse=True)
    def setup_test_environment(self):
        """Setup clean environment for each test."""
        # Store original environment
        self.original_env = os.environ.get("AIVILLAGE_ENV")
        yield
        # Restore original environment
        if self.original_env:
            os.environ["AIVILLAGE_ENV"] = self.original_env
        elif "AIVILLAGE_ENV" in os.environ:
            del os.environ["AIVILLAGE_ENV"]
    
    def test_cors_never_allows_wildcard_origins(self):
        """CRITICAL: Ensure wildcard origins are never allowed."""
        # Test all environment configurations
        for env in ["production", "staging", "development", None]:
            if env:
                os.environ["AIVILLAGE_ENV"] = env
            else:
                os.environ.pop("AIVILLAGE_ENV", None)
            
            # Get CORS origins for this environment
            secure_origins = get_secure_cors_origins()
            admin_origins = get_admin_cors_origins()
            websocket_origins = get_websocket_cors_origins()
            
            # Assert no wildcards
            assert "*" not in secure_origins, f"Wildcard found in secure origins for {env}"
            assert "*" not in admin_origins, f"Wildcard found in admin origins for {env}"
            assert "*" not in websocket_origins, f"Wildcard found in websocket origins for {env}"
            
            # Assert no catch-all patterns
            for origins in [secure_origins, admin_origins, websocket_origins]:
                for origin in origins:
                    assert not origin.endswith("*"), f"Catch-all pattern found: {origin}"
                    assert "://*" not in origin, f"Wildcard subdomain found: {origin}"
    
    def test_production_cors_is_most_restrictive(self):
        """Production environment must have the most restrictive CORS policy."""
        os.environ["AIVILLAGE_ENV"] = "production"
        
        prod_secure = get_secure_cors_origins()
        prod_admin = get_admin_cors_origins()
        
        # Production should have minimal origins
        assert len(prod_secure) <= 3, "Production secure CORS too permissive"
        assert len(prod_admin) == 1, "Production admin CORS must have exactly one origin"
        
        # All production origins must be HTTPS
        for origin in prod_secure + prod_admin:
            assert origin.startswith("https://"), f"Non-HTTPS origin in production: {origin}"
        
        # No localhost in production
        for origin in prod_secure + prod_admin:
            assert "localhost" not in origin, f"Localhost found in production CORS: {origin}"
            assert "127.0.0.1" not in origin, f"127.0.0.1 found in production CORS: {origin}"
    
    def test_admin_cors_more_restrictive_than_api(self):
        """Admin CORS must be more restrictive than regular API CORS."""
        for env in ["production", "staging", "development"]:
            os.environ["AIVILLAGE_ENV"] = env
            
            secure_origins = get_secure_cors_origins()
            admin_origins = get_admin_cors_origins()
            
            # Admin should have fewer or equal origins
            assert len(admin_origins) <= len(secure_origins), \
                f"Admin CORS more permissive than API CORS in {env}"
    
    def test_cors_config_immutability(self):
        """CORS configuration objects should be immutable to prevent tampering."""
        # Test that modifying returned lists doesn't affect future calls
        os.environ["AIVILLAGE_ENV"] = "production"
        
        origins1 = get_secure_cors_origins()
        original_length = len(origins1)
        
        # Try to modify the returned list
        origins1.append("https://malicious.example.com")
        
        # Get fresh copy
        origins2 = get_secure_cors_origins()
        
        assert len(origins2) == original_length, "CORS configuration was modified!"
        assert "https://malicious.example.com" not in origins2, "Malicious origin persisted!"
    
    def test_cors_config_constants_security(self):
        """Test security properties of CORS configuration constants."""
        # Test SECURE_CORS_CONFIG
        config = SECURE_CORS_CONFIG
        
        assert config["allow_credentials"] is True, "Credentials should be allowed for auth"
        assert "X-API-Key" in config["allow_headers"], "API key header missing"
        assert config["max_age"] > 0, "Max age should be positive"
        
        # Verify allowed methods are reasonable
        allowed_methods = config["allow_methods"]
        assert "OPTIONS" in allowed_methods, "OPTIONS required for CORS preflight"
        assert len(allowed_methods) <= 5, "Too many HTTP methods allowed"
        
        # Test ADMIN_CORS_CONFIG is more restrictive
        admin_config = ADMIN_CORS_CONFIG
        assert len(admin_config["allow_methods"]) <= len(config["allow_methods"]), \
            "Admin CORS should be more restrictive"
        assert admin_config["max_age"] <= config["max_age"], \
            "Admin CORS should have shorter cache time"
    
    @pytest.mark.parametrize("env,expected_protocol", [
        ("production", "https"),
        ("staging", "https"), 
        ("development", "http")
    ])
    def test_environment_specific_protocols(self, env: str, expected_protocol: str):
        """Test that each environment uses appropriate protocols."""
        os.environ["AIVILLAGE_ENV"] = env
        
        secure_origins = get_secure_cors_origins()
        
        if env == "production":
            # Production must be all HTTPS
            for origin in secure_origins:
                assert origin.startswith("https://"), \
                    f"Non-HTTPS origin in production: {origin}"
        elif env == "development":
            # Development can use HTTP for localhost
            localhost_origins = [o for o in secure_origins if "localhost" in o or "127.0.0.1" in o]
            for origin in localhost_origins:
                assert origin.startswith("http://"), \
                    f"Localhost should use HTTP in development: {origin}"
    
    def test_cors_headers_security_features(self):
        """Test that CORS headers include security features."""
        config = SECURE_CORS_CONFIG
        headers = config.get("allow_headers", [])
        
        # Security headers should be present
        security_headers = ["Authorization", "Content-Type"]
        for header in security_headers:
            assert header in headers, f"Required security header missing: {header}"
        
        # Dangerous headers should not be allowed
        dangerous_headers = ["X-Forwarded-For", "X-Real-IP", "Host"]
        for header in dangerous_headers:
            assert header not in headers, f"Dangerous header allowed: {header}"
    
    def test_websocket_cors_consistency(self):
        """WebSocket CORS should be consistent with API CORS."""
        for env in ["production", "staging", "development"]:
            os.environ["AIVILLAGE_ENV"] = env
            
            secure_origins = get_secure_cors_origins()
            websocket_origins = get_websocket_cors_origins()
            
            # WebSocket origins should match secure origins
            assert secure_origins == websocket_origins, \
                f"WebSocket CORS mismatch with secure CORS in {env}"


class TestCORSBehavioralContracts:
    """Behavioral contract tests for CORS configuration."""
    
    def test_cors_function_contracts(self):
        """Test that CORS functions maintain their contracts."""
        # Functions should always return lists
        for env in [None, "production", "staging", "development", "invalid"]:
            if env:
                os.environ["AIVILLAGE_ENV"] = env
            else:
                os.environ.pop("AIVILLAGE_ENV", None)
            
            secure = get_secure_cors_origins()
            admin = get_admin_cors_origins()
            websocket = get_websocket_cors_origins()
            
            assert isinstance(secure, list), f"get_secure_cors_origins returned {type(secure)}"
            assert isinstance(admin, list), f"get_admin_cors_origins returned {type(admin)}"
            assert isinstance(websocket, list), f"get_websocket_cors_origins returned {type(websocket)}"
            
            # All items should be strings
            assert all(isinstance(o, str) for o in secure), "Non-string in secure origins"
            assert all(isinstance(o, str) for o in admin), "Non-string in admin origins"
            assert all(isinstance(o, str) for o in websocket), "Non-string in websocket origins"
    
    def test_cors_origin_format_validation(self):
        """Test that all CORS origins are properly formatted URLs."""
        import re
        
        url_pattern = re.compile(
            r'^https?://'  # http:// or https://
            r'(?:[A-Z0-9](?:[A-Z0-9-]{0,61}[A-Z0-9])?\.)+'  # domain
            r'[A-Z]{2,6}\.?'  # host
            r'(?::\d+)?'  # optional port
            r'(?:/?|[/?]\S+)$', re.IGNORECASE  # optional path
        )
        
        # Also allow localhost patterns
        localhost_pattern = re.compile(
            r'^https?://(localhost|127\.0\.0\.1)(:\d+)?/?$', re.IGNORECASE
        )
        
        for env in ["production", "staging", "development"]:
            os.environ["AIVILLAGE_ENV"] = env
            
            all_origins = (get_secure_cors_origins() + 
                          get_admin_cors_origins() + 
                          get_websocket_cors_origins())
            
            for origin in all_origins:
                is_valid = (url_pattern.match(origin) or 
                           localhost_pattern.match(origin))
                assert is_valid, f"Invalid origin format in {env}: {origin}"
    
    def test_cors_no_injection_vulnerabilities(self):
        """Test that CORS configuration is not vulnerable to injection."""
        # Test with malicious environment variables
        malicious_values = [
            "production; rm -rf /",
            "production\nmalicious_code()",
            "production' OR '1'='1",
            "production<script>alert('xss')</script>",
            "../../../etc/passwd"
        ]
        
        for malicious in malicious_values:
            os.environ["AIVILLAGE_ENV"] = malicious
            
            try:
                origins = get_secure_cors_origins()
                
                # Should still return reasonable defaults
                assert isinstance(origins, list), f"Function broke with input: {malicious}"
                assert len(origins) > 0, f"No origins returned for: {malicious}"
                
                # Origins should not contain the malicious content
                for origin in origins:
                    assert malicious not in origin, f"Malicious content in origin: {origin}"
                    
            except Exception as e:
                # If function throws exception, that's acceptable defensive behavior
                import logging
                logging.exception("CORS validation failed for malicious input '%s': %s", malicious, str(e))