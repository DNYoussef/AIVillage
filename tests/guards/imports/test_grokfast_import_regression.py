#!/usr/bin/env python3
"""
GrokFast Import Regression Guard Tests
=====================================

Prevents regression in GrokFast import fixes.
Tests unified module structure and import resolution.

Generated by TDD London School Swarm Agent for Phase 5 guard protection.
"""

import pytest
import sys
import inspect
from pathlib import Path
from unittest.mock import patch, MagicMock

# Test paths
PROJECT_ROOT = Path(__file__).parent.parent.parent.parent
sys.path.insert(0, str(PROJECT_ROOT / "src"))


class TestGrokFastImportRegression:
    """Regression tests for GrokFast import fixes."""

    def test_grokfast_module_exists_and_importable(self):
        """CRITICAL: GrokFast unified module must be importable."""
        try:
            from src.core.grokfast import GrokFastOptimizer

            assert GrokFastOptimizer is not None, "GrokFastOptimizer class not found"
        except ImportError as e:
            pytest.fail(f"GrokFast module not importable: {e}")

    def test_grokfast_required_classes_available(self):
        """Test all required GrokFast classes are available."""
        from src.core.grokfast import GrokFastOptimizer, create_grokfast_adamw

        # Test class availability
        assert inspect.isclass(GrokFastOptimizer), "GrokFastOptimizer is not a class"
        assert callable(create_grokfast_adamw), "create_grokfast_adamw is not callable"

        # Test class has required methods
        optimizer_methods = [m for m in dir(GrokFastOptimizer) if not m.startswith("_")]
        required_methods = ["step", "zero_grad"]  # Basic optimizer methods

        for method in required_methods:
            if method in optimizer_methods:  # Only check if method exists
                assert callable(getattr(GrokFastOptimizer, method)), f"GrokFastOptimizer.{method} is not callable"

    def test_grokfast_factory_function_works(self):
        """Test GrokFast factory function creates valid optimizer."""
        from src.core.grokfast import create_grokfast_adamw

        # Mock parameters for testing
        mock_params = [MagicMock()]
        mock_params[0].requires_grad = True
        mock_params[0].data = MagicMock()

        try:
            optimizer = create_grokfast_adamw(mock_params, lr=0.001)
            assert optimizer is not None, "Factory function returned None"

            # Test optimizer has expected attributes
            assert hasattr(optimizer, "param_groups"), "Optimizer missing param_groups"
            assert hasattr(optimizer, "defaults"), "Optimizer missing defaults"

        except Exception as e:
            # If function requires specific PyTorch setup, that's acceptable
            if "torch" not in str(e).lower():
                pytest.fail(f"Factory function failed unexpectedly: {e}")

    def test_grokfast_module_public_api(self):
        """Test GrokFast module exports correct public API."""
        import src.core.grokfast as grokfast_module

        # Test __all__ exists and contains expected items
        if hasattr(grokfast_module, "__all__"):
            public_api = grokfast_module.__all__
            expected_items = ["GrokFastOptimizer", "create_grokfast_adamw"]

            for item in expected_items:
                assert item in public_api, f"Missing {item} in __all__"
                assert hasattr(grokfast_module, item), f"Missing {item} in module"

    def test_no_import_conflicts_with_existing_modules(self):
        """Test GrokFast import doesn't conflict with existing modules."""
        # Clear any existing imports
        modules_to_clear = [m for m in sys.modules.keys() if "grokfast" in m.lower()]
        for module in modules_to_clear:
            if module != "src.core.grokfast":  # Keep our unified module
                del sys.modules[module]

        # Import should not raise conflicts
        try:
            from src.core.grokfast import GrokFastOptimizer

            # Re-importing should work (idempotent)
            from src.core.grokfast import GrokFastOptimizer as GrokFastOptimizer2

            assert GrokFastOptimizer is GrokFastOptimizer2, "Re-import created different class objects"

        except ImportError as e:
            pytest.fail(f"Import conflict detected: {e}")

    def test_grokfast_module_file_structure(self):
        """Test GrokFast unified module file exists with correct structure."""
        grokfast_path = PROJECT_ROOT / "src" / "core" / "grokfast.py"

        assert grokfast_path.exists(), f"GrokFast module file not found: {grokfast_path}"
        assert grokfast_path.is_file(), "GrokFast path is not a file"
        assert grokfast_path.stat().st_size > 0, "GrokFast module file is empty"

        # Test core package __init__.py exists
        init_path = PROJECT_ROOT / "src" / "core" / "__init__.py"
        assert init_path.exists(), "Core package __init__.py missing"

    def test_grokfast_import_from_different_contexts(self):
        """Test GrokFast can be imported from different contexts."""
        import_contexts = [
            "from src.core.grokfast import GrokFastOptimizer",
            "from src.core.grokfast import create_grokfast_adamw",
            "import src.core.grokfast as gf",
            "from src.core import grokfast",
        ]

        for context in import_contexts:
            try:
                # Execute import in isolated namespace
                namespace = {}
                exec(context, {"__builtins__": __builtins__}, namespace)

                # Verify import succeeded
                if "GrokFastOptimizer" in context:
                    assert "GrokFastOptimizer" in namespace, f"Import failed: {context}"
                elif "create_grokfast_adamw" in context:
                    assert "create_grokfast_adamw" in namespace, f"Import failed: {context}"
                elif "gf" in context:
                    assert "gf" in namespace and hasattr(
                        namespace["gf"], "GrokFastOptimizer"
                    ), f"Module import failed: {context}"
                elif "grokfast" in context and "from" in context:
                    assert "grokfast" in namespace, f"Module import failed: {context}"

            except Exception as e:
                pytest.fail(f"Import context failed: {context} - {e}")

    def test_grokfast_module_has_proper_docstring(self):
        """Test GrokFast module has proper documentation."""
        import src.core.grokfast as grokfast_module

        assert grokfast_module.__doc__ is not None, "GrokFast module missing docstring"
        assert len(grokfast_module.__doc__) > 50, "GrokFast module docstring too short"

        # Should mention it's a unified implementation
        doc = grokfast_module.__doc__.lower()
        assert any(
            word in doc for word in ["unified", "consolidated", "grokfast"]
        ), "Docstring doesn't describe unified nature"

    def test_grokfast_import_performance(self):
        """Test GrokFast import is reasonably fast."""
        import time

        # Clear module from cache
        if "src.core.grokfast" in sys.modules:
            del sys.modules["src.core.grokfast"]

        start_time = time.time()


        import_time = time.time() - start_time

        # Import should be fast (< 100ms)
        assert import_time < 0.1, f"GrokFast import too slow: {import_time:.3f}s"

    def test_grokfast_handles_missing_dependencies_gracefully(self):
        """Test GrokFast handles missing PyTorch gracefully."""
        # Mock missing PyTorch
        with patch.dict("sys.modules", {"torch": None}):
            try:
                from src.core.grokfast import GrokFastOptimizer

                # Should import successfully even without torch
                assert GrokFastOptimizer is not None

            except ImportError as e:
                # If it fails due to torch dependency, error should be informative
                assert "torch" in str(e).lower() or "pytorch" in str(e).lower(), f"Uninformative import error: {e}"


class TestGrokFastBehavioralContracts:
    """Behavioral contract tests for GrokFast import system."""

    def test_grokfast_import_idempotency(self):
        """Contract: Multiple imports should be idempotent."""
        # Import multiple times
        import src.core.grokfast as gf1
        import src.core.grokfast as gf2
        from src.core.grokfast import GrokFastOptimizer as Opt1
        from src.core.grokfast import GrokFastOptimizer as Opt2

        # Should be same objects
        assert gf1 is gf2, "Module objects differ between imports"
        assert Opt1 is Opt2, "Class objects differ between imports"

    def test_grokfast_module_namespace_isolation(self):
        """Contract: GrokFast module doesn't pollute global namespace."""
        initial_globals = set(globals().keys())

        # Import GrokFast

        final_globals = set(globals().keys())

        # Should only add the explicitly imported names
        new_globals = final_globals - initial_globals
        expected_new = {"GrokFastOptimizer", "create_grokfast_adamw"}

        assert new_globals <= expected_new, f"Unexpected globals added: {new_globals - expected_new}"

    def test_grokfast_class_instantiation_contract(self):
        """Contract: GrokFast classes should be instantiable or provide clear errors."""
        from src.core.grokfast import GrokFastOptimizer

        # Test class instantiation (may require specific params)
        try:
            # Attempt basic instantiation
            instance = GrokFastOptimizer([])  # Empty parameter list

            # If successful, should have optimizer interface
            assert hasattr(instance, "step"), "GrokFastOptimizer missing step method"
            assert hasattr(instance, "zero_grad"), "GrokFastOptimizer missing zero_grad method"

        except Exception as e:
            # If instantiation fails, error should be informative
            error_msg = str(e).lower()
            acceptable_errors = ["parameter", "torch", "require", "argument", "missing"]

            assert any(word in error_msg for word in acceptable_errors), f"Uninformative instantiation error: {e}"

    def test_grokfast_factory_function_contract(self):
        """Contract: Factory functions should validate inputs or provide clear errors."""
        from src.core.grokfast import create_grokfast_adamw

        # Test with invalid inputs
        invalid_inputs = [
            (None, {}),  # None parameters
            ([], {"lr": "invalid"}),  # Invalid learning rate
            ([], {"lr": -1}),  # Negative learning rate
        ]

        for params, kwargs in invalid_inputs:
            try:
                optimizer = create_grokfast_adamw(params, **kwargs)

                # If it succeeds, should return valid optimizer-like object
                if optimizer is not None:
                    assert hasattr(optimizer, "step"), "Factory returned invalid optimizer"

            except Exception as e:
                # Errors should be related to input validation
                error_msg = str(e).lower()
                acceptable_errors = ["parameter", "learning", "rate", "invalid", "require"]

                assert any(
                    word in error_msg for word in acceptable_errors
                ), f"Uninformative factory error for {params}, {kwargs}: {e}"

    def test_grokfast_module_attributes_consistency(self):
        """Contract: Module attributes should be consistent across accesses."""
        import src.core.grokfast as grokfast_module

        # Get attributes multiple times
        attrs1 = dir(grokfast_module)
        attrs2 = dir(grokfast_module)

        assert attrs1 == attrs2, "Module attributes inconsistent across accesses"

        # Public API should be stable
        if hasattr(grokfast_module, "__all__"):
            api1 = list(grokfast_module.__all__)
            api2 = list(grokfast_module.__all__)
            assert api1 == api2, "Public API inconsistent"

    def test_grokfast_error_messages_are_helpful(self):
        """Contract: Error messages should be helpful for debugging."""
        # Test import error handling
        with patch("importlib.import_module") as mock_import:
            mock_import.side_effect = ImportError("Mock import failure")

            try:
                # Try to import something that would fail
                import importlib

                importlib.import_module("nonexistent.grokfast.module")

            except ImportError as e:
                # Error should contain useful information
                error_msg = str(e)
                assert len(error_msg) > 10, "Error message too short"
                assert "import" in error_msg.lower(), "Error message not about import"
