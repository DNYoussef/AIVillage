<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Agent Forge Control Panel</title>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            background: #1a1a1a; color: #e5e5e5; min-height: 100vh;
        }
        .container { padding: 20px; max-width: 1400px; margin: 0 auto; }
        .header { display: flex; justify-content: space-between; align-items: center; margin-bottom: 30px; padding-bottom: 15px; border-bottom: 1px solid #333; }
        .header h1 { color: #4ade80; margin: 0; font-size: 24px; font-weight: 600; }
        .connection-status { display: flex; align-items: center; gap: 8px; font-size: 14px; }
        .status-indicator { font-size: 12px; }
        .status-indicator.connected { color: #10b981; }
        .status-indicator.disconnected { color: #f59e0b; }
        .status-indicator.error { color: #ef4444; }

        /* Phase Control Section */
        .phase-section { margin-bottom: 40px; }
        .phase-section h2 { color: #4ade80; margin-bottom: 20px; font-size: 20px; }
        .phases-grid { display: grid; grid-template-columns: repeat(auto-fit, minmax(300px, 1fr)); gap: 20px; }
        .phase-card {
            background: #2d2d2d; border: 1px solid #404040; border-radius: 8px; padding: 20px;
            transition: all 0.3s ease;
        }
        .phase-card:hover { border-color: #4ade80; transform: translateY(-2px); }
        .phase-header { display: flex; justify-content: space-between; align-items: center; margin-bottom: 15px; }
        .phase-header h3 { margin: 0; color: #e5e5e5; font-size: 18px; }
        .status-badge {
            padding: 4px 12px; border-radius: 20px; font-size: 12px; font-weight: 600; color: white;
        }
        .status-badge.ready { background: #4ade80; }
        .status-badge.running { background: #3b82f6; }
        .status-badge.completed { background: #10b981; }
        .status-badge.error { background: #ef4444; }

        .progress-section { margin-bottom: 15px; }
        .progress-bar {
            width: 100%; height: 8px; background: #404040; border-radius: 4px; overflow: hidden; margin-bottom: 5px;
        }
        .progress-fill {
            height: 100%; background: linear-gradient(90deg, #4ade80, #10b981);
            border-radius: 4px; transition: width 0.3s ease;
        }
        .progress-text { font-size: 12px; color: #9ca3af; }
        .phase-message { font-size: 14px; color: #9ca3af; margin-bottom: 15px; min-height: 20px; }

        .phase-button {
            width: 100%; padding: 12px; border: none; border-radius: 6px; font-weight: 600;
            font-size: 14px; cursor: pointer; transition: all 0.3s ease; text-transform: uppercase;
        }
        .phase-button.ready { background: #4ade80; color: #1a1a1a; }
        .phase-button.ready:hover { background: #22c55e; transform: translateY(-1px); }
        .phase-button.running {
            background: #3b82f6; color: white; cursor: not-allowed; animation: pulse 2s infinite;
        }
        .phase-button.completed { background: #10b981; color: white; }
        .phase-button.error { background: #ef4444; color: white; }

        @keyframes pulse { 0%, 100% { opacity: 1; } 50% { opacity: 0.7; } }

        /* Metrics Section */
        .metrics-section { margin-bottom: 40px; }
        .metrics-section h2 { color: #4ade80; margin-bottom: 20px; font-size: 20px; }
        .metrics-grid { display: grid; grid-template-columns: repeat(auto-fit, minmax(250px, 1fr)); gap: 20px; }
        .metric-card {
            background: #2d2d2d; border: 1px solid #404040; border-radius: 8px;
            padding: 20px; text-align: center;
        }
        .metric-card h3 { margin: 0 0 10px 0; color: #e5e5e5; font-size: 16px; }
        .metric-value { font-size: 24px; font-weight: 700; color: #4ade80; margin-bottom: 10px; }
        .metric-bar {
            width: 100%; height: 6px; background: #404040; border-radius: 3px; overflow: hidden; margin-bottom: 8px;
        }
        .metric-fill {
            height: 100%; background: linear-gradient(90deg, #4ade80, #10b981);
            border-radius: 3px; transition: width 0.3s ease;
        }
        .metric-detail { font-size: 12px; color: #9ca3af; }

        /* Chat Section */
        .chat-section { margin-bottom: 40px; }
        .chat-section h2 { color: #4ade80; margin-bottom: 20px; font-size: 20px; }
        .model-selection { margin-bottom: 20px; }
        .model-selection label { display: block; margin-bottom: 8px; color: #e5e5e5; font-weight: 500; }
        .model-selection select {
            width: 100%; padding: 10px; background: #2d2d2d; border: 1px solid #404040;
            border-radius: 6px; color: #e5e5e5; font-size: 14px;
        }
        .model-selection select:focus { outline: none; border-color: #4ade80; }
        
        .chat-interface {
            background: #2d2d2d; border: 1px solid #404040; border-radius: 8px; overflow: hidden;
        }
        .chat-history { height: 300px; overflow-y: auto; padding: 20px; }
        .message { margin-bottom: 15px; padding: 12px; border-radius: 8px; max-width: 80%; }
        .message.user { background: #3b82f6; color: white; margin-left: auto; text-align: right; }
        .message.assistant { background: #404040; color: #e5e5e5; margin-right: auto; }
        .message-content { margin-bottom: 5px; }
        .message-meta { font-size: 12px; opacity: 0.7; }

        .chat-input {
            display: flex; padding: 15px; background: #333; border-top: 1px solid #404040;
        }
        .chat-input input {
            flex: 1; padding: 10px; background: #2d2d2d; border: 1px solid #404040;
            border-radius: 6px 0 0 6px; color: #e5e5e5; font-size: 14px;
        }
        .chat-input input:focus { outline: none; border-color: #4ade80; }
        .chat-input button {
            padding: 10px 20px; background: #4ade80; border: none; border-radius: 0 6px 6px 0;
            color: #1a1a1a; font-weight: 600; cursor: pointer; transition: background-color 0.3s ease;
        }
        .chat-input button:hover { background: #22c55e; }
        .chat-input button:disabled { background: #6b7280; cursor: not-allowed; }

        .no-models {
            background: #2d2d2d; border: 1px solid #404040; border-radius: 8px;
            padding: 40px; text-align: center;
        }
        .no-models p { color: #9ca3af; margin: 0; font-size: 16px; }

        .error-display {
            background: rgba(239, 68, 68, 0.1); border: 1px solid #ef4444;
            border-radius: 8px; padding: 15px; margin: 15px 0; color: #fecaca;
        }
        .error-display h4 { color: #ef4444; margin-bottom: 10px; }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1>ðŸ¤– Agent Forge Training Control</h1>
            <div class="connection-status">
                <span class="status-indicator" id="connection-indicator">â—‹</span>
                <span>WebSocket: <span id="connection-status">connecting...</span></span>
            </div>
        </div>

        <!-- Phase Control Section -->
        <div class="phase-section">
            <h2>Phase Control</h2>
            <div class="phases-grid" id="phases-grid">
                <!-- Phase cards will be populated by JavaScript -->
            </div>
        </div>

        <!-- System Metrics Section -->
        <div class="metrics-section">
            <h2>System Resources</h2>
            <div class="metrics-grid" id="metrics-grid">
                <!-- Metrics will be populated by JavaScript -->
            </div>
        </div>

        <!-- Model Chat Section -->
        <div class="chat-section">
            <h2>Model Testing</h2>
            <div class="model-selection" id="model-selection" style="display: none;">
                <label>Select Model:</label>
                <select id="model-select">
                    <option value="">Choose a model...</option>
                </select>
            </div>

            <div class="chat-interface" id="chat-interface" style="display: none;">
                <div class="chat-history" id="chat-history"></div>
                <div class="chat-input">
                    <input type="text" id="chat-message" placeholder="Chat with the model..." onkeypress="if(event.key==='Enter') sendChatMessage()">
                    <button onclick="sendChatMessage()" id="send-button" disabled>Send</button>
                </div>
            </div>

            <div class="no-models" id="no-models">
                <p>No trained models available yet. Complete a training phase to chat with models.</p>
            </div>
        </div>
    </div>

    <script>
        // Global state
        let phases = [];
        let models = [];
        let systemMetrics = null;
        let selectedModel = '';
        let chatHistory = [];
        let ws = null;
        let connectionStatus = 'disconnected';

        const API_BASE = 'http://localhost:8083';
        const CHAT_API = 'http://localhost:8084';
        const WS_URL = 'ws://localhost:8085/ws';

        // Initialize
        document.addEventListener('DOMContentLoaded', () => {
            connectWebSocket();
            loadPhases();
            loadModels();
            loadSystemMetrics();
            
            // Set up polling for fallback
            setInterval(() => {
                loadPhases();
                loadSystemMetrics();
            }, 5000);
        });

        // WebSocket connection
        function connectWebSocket() {
            try {
                ws = new WebSocket(WS_URL);
                
                ws.onopen = () => {
                    setConnectionStatus('connected');
                    ws.send(JSON.stringify({ type: 'subscribe', channel: 'agent_forge_phases' }));
                    ws.send(JSON.stringify({ type: 'subscribe', channel: 'system_metrics' }));
                    ws.send(JSON.stringify({ type: 'subscribe', channel: 'model_updates' }));
                };

                ws.onmessage = (event) => {
                    const data = JSON.parse(event.data);
                    handleWebSocketMessage(data);
                };

                ws.onclose = () => {
                    setConnectionStatus('disconnected');
                    setTimeout(connectWebSocket, 5000);
                };

                ws.onerror = () => {
                    setConnectionStatus('error');
                };
            } catch (error) {
                console.error('WebSocket connection failed:', error);
                setConnectionStatus('error');
            }
        }

        function setConnectionStatus(status) {
            connectionStatus = status;
            const indicator = document.getElementById('connection-indicator');
            const statusText = document.getElementById('connection-status');
            
            indicator.className = `status-indicator ${status}`;
            indicator.textContent = status === 'connected' ? 'â—' : 'â—‹';
            statusText.textContent = status;
        }

        function handleWebSocketMessage(data) {
            switch (data.type) {
                case 'phase_update':
                    updatePhaseStatus(data.phase_name, data.status, data.progress, data.message);
                    break;
                case 'system_metrics':
                    systemMetrics = data.metrics;
                    renderSystemMetrics();
                    break;
                case 'model_update':
                    if (data.event_type === 'created') {
                        loadModels();
                    }
                    break;
            }
        }

        // Data loading functions
        async function loadPhases() {
            try {
                const response = await fetch(`${API_BASE}/phases/status`);
                const data = await response.json();
                phases = data.phases || [];
                renderPhases();
            } catch (error) {
                console.error('Failed to load phases:', error);
                showError('Failed to connect to Agent Forge Controller');
            }
        }

        async function loadModels() {
            try {
                const response = await fetch(`${CHAT_API}/models`);
                const data = await response.json();
                models = data.models || [];
                renderModels();
            } catch (error) {
                console.error('Failed to load models:', error);
            }
        }

        async function loadSystemMetrics() {
            try {
                const response = await fetch(`${API_BASE}/system/metrics`);
                const data = await response.json();
                systemMetrics = data;
                renderSystemMetrics();
            } catch (error) {
                console.error('Failed to load system metrics:', error);
            }
        }

        // Rendering functions
        function renderPhases() {
            const grid = document.getElementById('phases-grid');
            grid.innerHTML = phases.map(phase => `
                <div class="phase-card">
                    <div class="phase-header">
                        <h3>${phase.phase_name}</h3>
                        <span class="status-badge ${phase.status}">
                            ${getStatusIcon(phase.status)} ${phase.status}
                        </span>
                    </div>
                    <div class="progress-section">
                        <div class="progress-bar">
                            <div class="progress-fill" style="width: ${phase.progress * 100}%"></div>
                        </div>
                        <span class="progress-text">${Math.round(phase.progress * 100)}%</span>
                    </div>
                    <div class="phase-message">${phase.message}</div>
                    <button class="phase-button ${phase.status}" 
                            onclick="startPhase('${phase.phase_name}')"
                            ${phase.status === 'running' ? 'disabled' : ''}>
                        ${phase.status === 'running' ? 'RUNNING...' : `START ${phase.phase_name.toUpperCase()}`}
                    </button>
                </div>
            `).join('');
        }

        function renderSystemMetrics() {
            if (!systemMetrics) return;
            
            const grid = document.getElementById('metrics-grid');
            let html = `
                <div class="metric-card">
                    <h3>CPU Usage</h3>
                    <div class="metric-value">${systemMetrics.cpu.usage_percent.toFixed(1)}%</div>
                    <div class="metric-bar">
                        <div class="metric-fill" style="width: ${systemMetrics.cpu.usage_percent}%"></div>
                    </div>
                    <div class="metric-detail">${systemMetrics.cpu.count} cores</div>
                </div>
                <div class="metric-card">
                    <h3>Memory Usage</h3>
                    <div class="metric-value">${systemMetrics.memory.usage_percent.toFixed(1)}%</div>
                    <div class="metric-bar">
                        <div class="metric-fill" style="width: ${systemMetrics.memory.usage_percent}%"></div>
                    </div>
                    <div class="metric-detail">${(systemMetrics.memory.total_gb - systemMetrics.memory.available_gb).toFixed(1)} / ${systemMetrics.memory.total_gb.toFixed(1)} GB</div>
                </div>
            `;
            
            if (systemMetrics.gpu && Object.keys(systemMetrics.gpu).length > 0) {
                html += `
                    <div class="metric-card">
                        <h3>GPU Memory</h3>
                        <div class="metric-value">${systemMetrics.gpu.gpu_memory_used?.toFixed(1) || 0} / ${systemMetrics.gpu.gpu_memory_total?.toFixed(1) || 0} GB</div>
                        <div class="metric-bar">
                            <div class="metric-fill" style="width: ${((systemMetrics.gpu.gpu_memory_used || 0) / (systemMetrics.gpu.gpu_memory_total || 1)) * 100}%"></div>
                        </div>
                        <div class="metric-detail">${systemMetrics.gpu.gpu_name || 'GPU'}</div>
                    </div>
                `;
            }
            
            grid.innerHTML = html;
        }

        function renderModels() {
            const modelSelect = document.getElementById('model-select');
            const modelSelection = document.getElementById('model-selection');
            const chatInterface = document.getElementById('chat-interface');
            const noModels = document.getElementById('no-models');

            if (models.length > 0) {
                modelSelection.style.display = 'block';
                noModels.style.display = 'none';
                
                modelSelect.innerHTML = '<option value="">Choose a model...</option>' +
                    models.map(model => 
                        `<option value="${model.model_id}">${model.model_name} (${model.phase_name}) - ${(model.parameter_count / 1000000).toFixed(1)}M params</option>`
                    ).join('');

                modelSelect.onchange = (e) => {
                    selectedModel = e.target.value;
                    chatInterface.style.display = selectedModel ? 'block' : 'none';
                    document.getElementById('send-button').disabled = !selectedModel;
                };
            } else {
                modelSelection.style.display = 'none';
                chatInterface.style.display = 'none';
                noModels.style.display = 'block';
            }
        }

        // Action functions
        async function startPhase(phaseName) {
            try {
                let endpoint = '';
                switch (phaseName) {
                    case 'Cognate':
                        endpoint = '/phases/cognate/start';
                        break;
                    case 'EvoMerge':
                        endpoint = '/phases/evomerge/start';
                        break;
                    default:
                        showError(`Phase ${phaseName} not yet implemented`);
                        return;
                }

                const response = await fetch(`${API_BASE}${endpoint}`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({})
                });

                if (response.ok) {
                    const data = await response.json();
                    console.log(`Started ${phaseName} phase:`, data);
                    loadPhases(); // Refresh phase status
                } else {
                    showError(`Failed to start ${phaseName} phase`);
                }
            } catch (error) {
                console.error(`Error starting ${phaseName} phase:`, error);
                showError(`Error starting ${phaseName} phase: ${error.message}`);
            }
        }

        async function sendChatMessage() {
            if (!selectedModel || !document.getElementById('chat-message').value.trim()) return;

            const message = document.getElementById('chat-message').value;
            
            try {
                const response = await fetch(`${CHAT_API}/chat`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ model_id: selectedModel, message: message })
                });

                if (response.ok) {
                    const data = await response.json();
                    addChatMessage('user', message);
                    addChatMessage('assistant', data.response, data.model_name, data.response_time_ms);
                    document.getElementById('chat-message').value = '';
                } else {
                    showError('Failed to send message');
                }
            } catch (error) {
                console.error('Chat error:', error);
                showError(`Chat error: ${error.message}`);
            }
        }

        // Helper functions
        function getStatusIcon(status) {
            switch (status) {
                case 'ready': return 'â—‹';
                case 'running': return 'âŸ³';
                case 'completed': return 'âœ“';
                case 'error': return 'âœ—';
                default: return 'â—‹';
            }
        }

        function updatePhaseStatus(phaseName, status, progress, message) {
            const phaseIndex = phases.findIndex(p => p.phase_name === phaseName);
            if (phaseIndex !== -1) {
                phases[phaseIndex] = { ...phases[phaseIndex], status, progress, message };
                renderPhases();
            }
        }

        function addChatMessage(role, content, model, time) {
            chatHistory.push({ role, content, model, time });
            
            const chatHistoryDiv = document.getElementById('chat-history');
            const messageDiv = document.createElement('div');
            messageDiv.className = `message ${role}`;
            messageDiv.innerHTML = `
                <div class="message-content">${content}</div>
                ${model ? `<div class="message-meta">${model} - ${time}ms</div>` : ''}
            `;
            chatHistoryDiv.appendChild(messageDiv);
            chatHistoryDiv.scrollTop = chatHistoryDiv.scrollHeight;
        }

        function showError(message) {
            const errorDiv = document.createElement('div');
            errorDiv.className = 'error-display';
            errorDiv.innerHTML = `
                <h4>Error</h4>
                <p>${message}</p>
            `;
            document.querySelector('.container').insertBefore(errorDiv, document.querySelector('.phase-section'));
            
            setTimeout(() => {
                errorDiv.remove();
            }, 5000);
        }
    </script>
</body>
</html>