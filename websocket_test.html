<!DOCTYPE html>
<html>
<head>
    <title>WebSocket Test - Agent Forge Progress</title>
    <style>
        body { font-family: monospace; background: #1a1a1a; color: #e5e5e5; padding: 20px; }
        .status { padding: 10px; margin: 10px 0; border-radius: 5px; }
        .connected { background: #10b981; color: white; }
        .disconnected { background: #ef4444; color: white; }
        .progress-bar { width: 300px; height: 20px; background: #374151; border-radius: 10px; overflow: hidden; margin: 10px 0; }
        .progress-fill { height: 100%; background: linear-gradient(90deg, #3b82f6, #10b981); transition: width 0.3s ease; }
        .message-log { background: #111; padding: 10px; border-radius: 5px; max-height: 300px; overflow-y: auto; margin: 20px 0; }
        .message { margin: 5px 0; }
        .phase-update { color: #4ade80; }
        .system-metrics { color: #fbbf24; }
        .model-update { color: #3b82f6; }
        button { padding: 10px 15px; background: #4ade80; color: #1a1a1a; border: none; border-radius: 5px; cursor: pointer; margin: 5px; }
        button:hover { background: #22c55e; }
    </style>
</head>
<body>
    <h1>üöÄ Agent Forge Progress Monitor</h1>

    <div id="connection-status" class="status disconnected">
        WebSocket: Disconnected
    </div>

    <h3>Cognate Phase Progress</h3>
    <div class="progress-bar">
        <div id="progress-fill" class="progress-fill" style="width: 0%"></div>
    </div>
    <div id="progress-text">0% - Waiting for updates...</div>

    <button onclick="startCognatePhase()">Start Cognate Phase</button>
    <button onclick="checkPhaseStatus()">Check Status</button>
    <button onclick="clearLog()">Clear Log</button>

    <h3>Real-time Message Log</h3>
    <div id="message-log" class="message-log"></div>

    <script>
        let ws = null;
        let reconnectAttempts = 0;
        const maxReconnectAttempts = 5;

        function connect() {
            try {
                ws = new WebSocket('ws://localhost:8085/ws');

                ws.onopen = function() {
                    console.log('WebSocket connected');
                    document.getElementById('connection-status').textContent = 'WebSocket: Connected';
                    document.getElementById('connection-status').className = 'status connected';
                    reconnectAttempts = 0;

                    // Subscribe to channels
                    ws.send(JSON.stringify({ type: 'subscribe', channel: 'agent_forge_phases' }));
                    ws.send(JSON.stringify({ type: 'subscribe', channel: 'system_metrics' }));
                    ws.send(JSON.stringify({ type: 'subscribe', channel: 'model_updates' }));

                    addMessage('üîó Connected to WebSocket, subscribed to channels', 'phase-update');
                };

                ws.onmessage = function(event) {
                    const data = JSON.parse(event.data);
                    console.log('WebSocket message:', data);
                    handleMessage(data);
                };

                ws.onclose = function() {
                    console.log('WebSocket disconnected');
                    document.getElementById('connection-status').textContent = 'WebSocket: Disconnected';
                    document.getElementById('connection-status').className = 'status disconnected';

                    // Attempt to reconnect
                    if (reconnectAttempts < maxReconnectAttempts) {
                        reconnectAttempts++;
                        addMessage(`‚ö†Ô∏è Connection lost, reconnecting... (${reconnectAttempts}/${maxReconnectAttempts})`, 'system-metrics');
                        setTimeout(connect, 2000);
                    } else {
                        addMessage('‚ùå Max reconnection attempts reached', 'system-metrics');
                    }
                };

                ws.onerror = function(error) {
                    console.error('WebSocket error:', error);
                    addMessage('‚ùå WebSocket connection error', 'system-metrics');
                };
            } catch (error) {
                console.error('Failed to connect:', error);
                addMessage('‚ùå Failed to establish WebSocket connection', 'system-metrics');
            }
        }

        function handleMessage(data) {
            switch (data.type) {
                case 'phase_update':
                    if (data.phase_name === 'Cognate') {
                        updateProgress(data.progress, data.message, data.status);
                    }
                    addMessage(`üìä Phase Update: ${data.phase_name} - ${data.status} (${Math.round(data.progress * 100)}%) - ${data.message}`, 'phase-update');
                    break;

                case 'system_metrics':
                    addMessage(`üíª System: CPU ${data.metrics.cpu.usage_percent?.toFixed(1)}%, Memory ${data.metrics.memory.usage_percent?.toFixed(1)}%`, 'system-metrics');
                    break;

                case 'model_update':
                    addMessage(`ü§ñ Model: ${data.event_type} - ${data.data.model_name}`, 'model-update');
                    break;

                case 'connection_established':
                    addMessage(`‚úÖ Connection established: ${data.client_id}`, 'phase-update');
                    break;

                case 'subscription_confirmed':
                    addMessage(`üì° Subscribed to: ${data.channel}`, 'phase-update');
                    break;

                default:
                    addMessage(`üì® ${data.type}: ${JSON.stringify(data)}`, 'system-metrics');
            }
        }

        function updateProgress(progress, message, status) {
            const progressFill = document.getElementById('progress-fill');
            const progressText = document.getElementById('progress-text');

            progressFill.style.width = `${progress * 100}%`;
            progressText.textContent = `${Math.round(progress * 100)}% - ${message}`;

            // Change color based on status
            if (status === 'completed') {
                progressFill.style.background = '#10b981';
            } else if (status === 'error') {
                progressFill.style.background = '#ef4444';
            } else {
                progressFill.style.background = 'linear-gradient(90deg, #3b82f6, #10b981)';
            }
        }

        function addMessage(message, type = 'message') {
            const log = document.getElementById('message-log');
            const div = document.createElement('div');
            div.className = `message ${type}`;
            div.textContent = `[${new Date().toLocaleTimeString()}] ${message}`;
            log.appendChild(div);
            log.scrollTop = log.scrollHeight;
        }

        function startCognatePhase() {
            fetch('http://localhost:8083/phases/cognate/start', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({})
            })
            .then(response => response.json())
            .then(data => {
                addMessage(`üöÄ Started Cognate phase: ${data.message}`, 'phase-update');
            })
            .catch(error => {
                addMessage(`‚ùå Failed to start Cognate phase: ${error}`, 'system-metrics');
            });
        }

        function checkPhaseStatus() {
            fetch('http://localhost:8083/phases/status')
            .then(response => response.json())
            .then(data => {
                const cognate = data.phases.find(p => p.phase_name === 'Cognate');
                if (cognate) {
                    updateProgress(cognate.progress, cognate.message, cognate.status);
                    addMessage(`üìä Status: ${cognate.status} (${Math.round(cognate.progress * 100)}%) - ${cognate.message}`, 'phase-update');
                }
            })
            .catch(error => {
                addMessage(`‚ùå Failed to get status: ${error}`, 'system-metrics');
            });
        }

        function clearLog() {
            document.getElementById('message-log').innerHTML = '';
        }

        // Connect when page loads
        connect();

        // Check status every 10 seconds
        setInterval(checkPhaseStatus, 10000);
    </script>
</body>
</html>
