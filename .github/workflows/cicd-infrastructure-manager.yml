name: CI/CD Infrastructure Manager

on:
  push:
    branches: [main]
    paths:
      - '.github/workflows/**'
      - 'scripts/cicd/**'
      - 'config/ci/**'
  pull_request:
    branches: [main]
    paths:
      - '.github/workflows/**'
  schedule:
    - cron: '0 6 * * 1'  # Weekly on Monday at 6 AM UTC
  workflow_dispatch:
    inputs:
      action:
        description: 'Infrastructure action'
        required: true
        default: 'health-check'
        type: choice
        options:
          - 'health-check'
          - 'performance-analysis'
          - 'security-audit'
          - 'cleanup-artifacts'
          - 'update-dependencies'
          - 'generate-reports'
      target_workflows:
        description: 'Target workflows (comma-separated, or "all")'
        required: false
        default: 'all'
        type: string

env:
  INFRASTRUCTURE_VERSION: '2.0'
  CACHE_VERSION: 'infra-v3'
  RETENTION_POLICY_DAYS: 30
  SECURITY_RETENTION_DAYS: 90

# Prevent concurrent infrastructure operations
concurrency:
  group: cicd-infrastructure
  cancel-in-progress: false

jobs:
  # ============================================
  # STAGE 1: Infrastructure Health Check
  # ============================================
  infrastructure-health:
    name: Infrastructure Health Check
    runs-on: ubuntu-latest
    timeout-minutes: 15
    outputs:
      health-score: ${{ steps.health-analysis.outputs.score }}
      workflow-count: ${{ steps.workflow-discovery.outputs.count }}
      issues-found: ${{ steps.health-analysis.outputs.issues }}
    steps:
      - name: Checkout Repository
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Setup Python Environment
        uses: actions/setup-python@v5
        with:
          python-version: '3.11'

      - name: Install Analysis Tools
        run: |
          python -m pip install --upgrade pip
          pip install pyyaml jsonschema requests click tabulate
          pip install github-action-benchmark

      - name: "üîç Workflow Discovery"
        id: workflow-discovery
        run: |
          echo "üîç Discovering GitHub workflows..."
          
          workflow_files=($(find .github/workflows -name "*.yml" -o -name "*.yaml"))
          workflow_count=${#workflow_files[@]}
          
          echo "Found $workflow_count workflow files:"
          for file in "${workflow_files[@]}"; do
            echo "  - $(basename "$file")"
          done
          
          echo "count=$workflow_count" >> $GITHUB_OUTPUT
          
          # Create workflow inventory
          mkdir -p artifacts/infrastructure
          cat > artifacts/infrastructure/workflow-inventory.json << EOF
          {
            "timestamp": "$(date -Iseconds)",
            "total_workflows": $workflow_count,
            "workflows": [
          $(printf '    "%s"' "${workflow_files[@]}" | sed 's|\.github/workflows/||g' | paste -sd,)
            ]
          }
          EOF

      - name: "üìä Workflow Health Analysis"
        id: health-analysis
        run: |
          echo "üìä Analyzing workflow health..."
          
          total_score=100
          issues_found=0
          health_issues=()
          
          # Check for common issues
          echo "Checking for common workflow issues..."
          
          # 1. Check for outdated action versions
          outdated_actions=$(grep -r "uses:" .github/workflows/ | grep -E "(v1|v2|@v[12])" | wc -l || echo "0")
          if [[ $outdated_actions -gt 0 ]]; then
            health_issues+=("Outdated actions detected: $outdated_actions")
            total_score=$((total_score - outdated_actions * 5))
            ((issues_found++))
          fi
          
          # 2. Check for missing timeout configurations
          missing_timeouts=$(grep -L "timeout-minutes" .github/workflows/*.yml | wc -l || echo "0")
          if [[ $missing_timeouts -gt 0 ]]; then
            health_issues+=("Missing timeout configurations: $missing_timeouts")
            total_score=$((total_score - missing_timeouts * 3))
            ((issues_found++))
          fi
          
          # 3. Check for missing concurrency controls
          missing_concurrency=$(grep -L "concurrency:" .github/workflows/*.yml | wc -l || echo "0")
          if [[ $missing_concurrency -gt 2 ]]; then
            health_issues+=("Missing concurrency controls: $missing_concurrency")
            total_score=$((total_score - 10))
            ((issues_found++))
          fi
          
          # 4. Check for hardcoded secrets
          hardcoded_secrets=$(grep -r -i "password\|secret\|token" .github/workflows/ | grep -E "(=|:)" | grep -v "\${{" | wc -l || echo "0")
          if [[ $hardcoded_secrets -gt 0 ]]; then
            health_issues+=("Potential hardcoded secrets: $hardcoded_secrets")
            total_score=$((total_score - hardcoded_secrets * 15))
            ((issues_found++))
          fi
          
          # 5. Check for missing artifact retention policies
          missing_retention=$(grep -L "retention-days" .github/workflows/*.yml | wc -l || echo "0")
          if [[ $missing_retention -gt 0 ]]; then
            health_issues+=("Missing retention policies: $missing_retention")
            total_score=$((total_score - missing_retention * 2))
            ((issues_found++))
          fi
          
          # Ensure score doesn't go below 0
          if [[ $total_score -lt 0 ]]; then
            total_score=0
          fi
          
          echo "Health Analysis Results:"
          echo "  Overall Score: $total_score/100"
          echo "  Issues Found: $issues_found"
          
          if [[ $issues_found -gt 0 ]]; then
            echo "  Issues Details:"
            for issue in "${health_issues[@]}"; do
              echo "    - $issue"
            done
          fi
          
          # Generate health report
          cat > artifacts/infrastructure/health-report.json << EOF
          {
            "timestamp": "$(date -Iseconds)",
            "overall_score": $total_score,
            "issues_count": $issues_found,
            "issues": [
          $(printf '      "%s"' "${health_issues[@]}" | paste -sd,)
            ],
            "recommendations": [
              "Update action versions to latest (v4+)",
              "Add timeout-minutes to all jobs",
              "Implement concurrency controls",
              "Use secrets properly with \${{ secrets.NAME }}",
              "Add retention-days to all artifacts"
            ]
          }
          EOF
          
          echo "score=$total_score" >> $GITHUB_OUTPUT
          echo "issues=$issues_found" >> $GITHUB_OUTPUT

      - name: "‚ö° Performance Analysis"
        run: |
          echo "‚ö° Analyzing workflow performance characteristics..."
          
          # Analyze workflow complexity and performance patterns
          total_jobs=0
          total_steps=0
          parallel_jobs=0
          
          for workflow in .github/workflows/*.yml; do
            if [[ -f "$workflow" ]]; then
              workflow_name=$(basename "$workflow")
              
              # Count jobs and steps
              jobs=$(yq eval '.jobs | keys | length' "$workflow" 2>/dev/null || echo "0")
              steps=$(yq eval '[.jobs[].steps] | flatten | length' "$workflow" 2>/dev/null || echo "0")
              
              total_jobs=$((total_jobs + jobs))
              total_steps=$((total_steps + steps))
              
              # Check for matrix strategies (parallel execution)
              has_matrix=$(yq eval '.jobs[].strategy.matrix' "$workflow" 2>/dev/null | grep -v "null" | wc -l || echo "0")
              if [[ $has_matrix -gt 0 ]]; then
                ((parallel_jobs++))
              fi
              
              echo "  $workflow_name: $jobs jobs, $steps steps, matrix: $has_matrix"
            fi
          done
          
          echo "Performance Analysis Summary:"
          echo "  Total Jobs: $total_jobs"
          echo "  Total Steps: $total_steps"
          echo "  Parallel Workflows: $parallel_jobs"
          echo "  Avg Jobs per Workflow: $((total_jobs / workflow_count))"
          
          # Generate performance report
          cat > artifacts/infrastructure/performance-analysis.json << EOF
          {
            "timestamp": "$(date -Iseconds)",
            "metrics": {
              "total_jobs": $total_jobs,
              "total_steps": $total_steps,
              "parallel_workflows": $parallel_jobs,
              "average_jobs_per_workflow": $((total_jobs / ${workflow_count:-1}))
            },
            "performance_score": $(( (parallel_jobs * 100) / ${workflow_count:-1} ))
          }
          EOF

      - name: Upload Infrastructure Analysis
        uses: actions/upload-artifact@v4
        with:
          name: infrastructure-analysis-${{ github.run_id }}
          path: artifacts/infrastructure/
          retention-days: ${{ env.RETENTION_POLICY_DAYS }}

  # ============================================
  # STAGE 2: Security Infrastructure Audit
  # ============================================
  security-infrastructure-audit:
    name: Security Infrastructure Audit
    runs-on: ubuntu-latest
    timeout-minutes: 20
    needs: infrastructure-health
    if: github.event.inputs.action == 'security-audit' || github.event.inputs.action == 'health-check'
    outputs:
      security-score: ${{ steps.security-analysis.outputs.score }}
      vulnerabilities: ${{ steps.security-analysis.outputs.vulnerabilities }}
    steps:
      - name: Checkout Repository
        uses: actions/checkout@v4

      - name: Setup Security Tools
        run: |
          pip install pyyaml semgrep bandit safety detect-secrets
          
          # Install additional security analysis tools
          pip install pip-audit cyclonedx-bom

      - name: "üîê Workflow Security Scanning"
        id: workflow-security
        run: |
          echo "üîê Scanning workflows for security issues..."
          
          mkdir -p artifacts/security-audit
          
          # Scan for secrets in workflows
          echo "Scanning for secrets..."
          detect-secrets scan .github/workflows/ \
            --force-use-all-plugins \
            --baseline artifacts/security-audit/workflow-secrets-baseline.json || true
          
          # Check for insecure patterns
          security_issues=0
          
          # 1. Check for pull_request_target usage (potential security risk)
          prt_usage=$(grep -r "pull_request_target" .github/workflows/ | wc -l || echo "0")
          if [[ $prt_usage -gt 0 ]]; then
            echo "‚ö†Ô∏è Found $prt_usage uses of pull_request_target (review required)"
            ((security_issues++))
          fi
          
          # 2. Check for script injection vulnerabilities
          script_injection=$(grep -r "\${{.*github\\.event\\..*}}" .github/workflows/ | grep -E "(run:|shell:)" | wc -l || echo "0")
          if [[ $script_injection -gt 0 ]]; then
            echo "‚ö†Ô∏è Potential script injection vulnerabilities: $script_injection"
            ((security_issues++))
          fi
          
          # 3. Check for overly permissive permissions
          broad_permissions=$(grep -r "permissions:" .github/workflows/ -A 5 | grep -E "(write-all|contents: write|actions: write)" | wc -l || echo "0")
          if [[ $broad_permissions -gt 5 ]]; then
            echo "‚ö†Ô∏è Overly broad permissions detected: $broad_permissions"
            ((security_issues++))
          fi
          
          # 4. Check for third-party actions without version pinning
          unpinned_actions=$(grep -r "uses:" .github/workflows/ | grep -v "@" | wc -l || echo "0")
          if [[ $unpinned_actions -gt 0 ]]; then
            echo "‚ö†Ô∏è Unpinned third-party actions: $unpinned_actions"
            ((security_issues++))
          fi
          
          echo "security-issues=$security_issues" >> $GITHUB_OUTPUT

      - name: "üõ°Ô∏è Dependency Security Audit"
        run: |
          echo "üõ°Ô∏è Auditing action dependencies..."
          
          # Extract all used actions
          grep -hr "uses:" .github/workflows/ | sed 's/.*uses: *//' | sed 's/@.*//' | sort -u > artifacts/security-audit/used-actions.txt
          
          echo "Third-party actions in use:"
          cat artifacts/security-audit/used-actions.txt
          
          # Check for known vulnerable actions
          vulnerable_actions=0
          while IFS= read -r action; do
            # Simple check for common vulnerable patterns
            if [[ "$action" == *"checkout@v1"* ]] || [[ "$action" == *"setup-*@v1"* ]]; then
              echo "‚ö†Ô∏è Potentially vulnerable action: $action"
              ((vulnerable_actions++))
            fi
          done < artifacts/security-audit/used-actions.txt
          
          echo "Vulnerable actions found: $vulnerable_actions"

      - name: "üìä Security Analysis Summary"
        id: security-analysis
        run: |
          echo "üìä Generating security analysis summary..."
          
          workflow_security_issues="${{ steps.workflow-security.outputs.security-issues }}"
          
          # Calculate security score
          base_score=100
          total_deductions=$((workflow_security_issues * 10))
          security_score=$((base_score - total_deductions))
          
          if [[ $security_score -lt 0 ]]; then
            security_score=0
          fi
          
          total_vulnerabilities=$workflow_security_issues
          
          echo "Security Analysis Results:"
          echo "  Security Score: $security_score/100"
          echo "  Total Vulnerabilities: $total_vulnerabilities"
          
          # Generate comprehensive security report
          cat > artifacts/security-audit/security-summary.json << EOF
          {
            "timestamp": "$(date -Iseconds)",
            "security_score": $security_score,
            "total_vulnerabilities": $total_vulnerabilities,
            "categories": {
              "workflow_security_issues": $workflow_security_issues,
              "dependency_vulnerabilities": 0
            },
            "recommendations": [
              "Review all pull_request_target usage",
              "Eliminate script injection vulnerabilities",
              "Use minimal necessary permissions",
              "Pin all third-party actions to specific versions",
              "Regular security audits of workflow dependencies"
            ]
          }
          EOF
          
          echo "score=$security_score" >> $GITHUB_OUTPUT
          echo "vulnerabilities=$total_vulnerabilities" >> $GITHUB_OUTPUT

      - name: Upload Security Audit Results
        uses: actions/upload-artifact@v4
        with:
          name: security-audit-${{ github.run_id }}
          path: artifacts/security-audit/
          retention-days: ${{ env.SECURITY_RETENTION_DAYS }}

  # ============================================
  # STAGE 3: Artifact & Cache Management
  # ============================================
  artifact-cache-management:
    name: Artifact & Cache Management
    runs-on: ubuntu-latest
    timeout-minutes: 25
    if: github.event.inputs.action == 'cleanup-artifacts' || github.event.inputs.action == 'health-check'
    outputs:
      cleanup-summary: ${{ steps.cleanup-summary.outputs.summary }}
    steps:
      - name: Checkout Repository
        uses: actions/checkout@v4

      - name: Setup GitHub CLI
        run: |
          # GitHub CLI is pre-installed on GitHub runners
          gh --version

      - name: "üßπ Analyze Artifact Usage"
        id: artifact-analysis
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          echo "üßπ Analyzing artifact usage patterns..."
          
          mkdir -p artifacts/cleanup
          
          # Get workflow runs from the last 30 days
          gh api repos/${{ github.repository }}/actions/runs \
            --jq '.workflow_runs[] | select(.created_at > (now - 30*24*3600 | todate)) | {id, name, status, created_at}' \
            > artifacts/cleanup/recent-runs.json
          
          total_runs=$(cat artifacts/cleanup/recent-runs.json | jq -s 'length')
          successful_runs=$(cat artifacts/cleanup/recent-runs.json | jq -s '[.[] | select(.status == "completed")] | length')
          
          echo "Workflow Run Analysis (Last 30 days):"
          echo "  Total Runs: $total_runs"
          echo "  Successful Runs: $successful_runs"
          echo "  Success Rate: $(( (successful_runs * 100) / total_runs ))%"
          
          # Analyze artifacts
          gh api repos/${{ github.repository }}/actions/artifacts \
            --jq '.artifacts[] | {id, name, size_in_bytes, created_at, expired}' \
            > artifacts/cleanup/artifacts-inventory.json
          
          total_artifacts=$(cat artifacts/cleanup/artifacts-inventory.json | jq -s 'length')
          total_size=$(cat artifacts/cleanup/artifacts-inventory.json | jq -s '[.[].size_in_bytes] | add // 0')
          expired_artifacts=$(cat artifacts/cleanup/artifacts-inventory.json | jq -s '[.[] | select(.expired == true)] | length')
          
          echo "Artifact Analysis:"
          echo "  Total Artifacts: $total_artifacts"
          echo "  Total Size: $(( total_size / 1024 / 1024 )) MB"
          echo "  Expired Artifacts: $expired_artifacts"
          
          echo "total-artifacts=$total_artifacts" >> $GITHUB_OUTPUT
          echo "total-size-mb=$(( total_size / 1024 / 1024 ))" >> $GITHUB_OUTPUT
          echo "expired-artifacts=$expired_artifacts" >> $GITHUB_OUTPUT

      - name: "üóëÔ∏è Intelligent Cleanup Strategy"
        id: cleanup-strategy
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          echo "üóëÔ∏è Implementing intelligent cleanup strategy..."
          
          cleanup_count=0
          space_freed=0
          
          # Strategy 1: Remove artifacts from failed runs older than 7 days
          echo "Cleaning up artifacts from old failed runs..."
          
          cutoff_date=$(date -d '7 days ago' --iso-8601=seconds)
          
          # Get failed runs older than cutoff
          gh api repos/${{ github.repository }}/actions/runs \
            --jq ".workflow_runs[] | select(.status != \"completed\" and .created_at < \"$cutoff_date\") | .id" \
            > artifacts/cleanup/failed-runs-to-clean.txt
          
          while IFS= read -r run_id; do
            if [[ -n "$run_id" ]]; then
              echo "Processing run $run_id..."
              
              # Get artifacts for this run
              gh api repos/${{ github.repository }}/actions/runs/$run_id/artifacts \
                --jq '.artifacts[] | {id, name, size_in_bytes}' > artifacts/cleanup/run-$run_id-artifacts.json
              
              # Clean up artifacts from this run
              cat artifacts/cleanup/run-$run_id-artifacts.json | jq -r '.id' | while IFS= read -r artifact_id; do
                if [[ -n "$artifact_id" ]]; then
                  echo "Deleting artifact $artifact_id..."
                  gh api --method DELETE repos/${{ github.repository }}/actions/artifacts/$artifact_id || echo "Failed to delete $artifact_id"
                  ((cleanup_count++))
                fi
              done
            fi
          done < artifacts/cleanup/failed-runs-to-clean.txt
          
          # Strategy 2: Remove duplicate artifacts (keep only latest 3 per name)
          echo "Cleaning up duplicate artifacts..."
          
          # Get all artifacts grouped by name
          gh api repos/${{ github.repository }}/actions/artifacts \
            --jq '.artifacts | group_by(.name) | .[] | select(length > 3) | sort_by(.created_at) | .[:-3] | .[].id' \
            > artifacts/cleanup/duplicate-artifacts.txt
          
          duplicate_count=0
          while IFS= read -r artifact_id; do
            if [[ -n "$artifact_id" ]]; then
              echo "Deleting duplicate artifact $artifact_id..."
              gh api --method DELETE repos/${{ github.repository }}/actions/artifacts/$artifact_id || echo "Failed to delete $artifact_id"
              ((duplicate_count++))
            fi
          done < artifacts/cleanup/duplicate-artifacts.txt
          
          total_cleaned=$((cleanup_count + duplicate_count))
          
          echo "Cleanup Results:"
          echo "  Failed Run Artifacts Cleaned: $cleanup_count"
          echo "  Duplicate Artifacts Cleaned: $duplicate_count"
          echo "  Total Cleaned: $total_cleaned"
          
          echo "cleanup-count=$total_cleaned" >> $GITHUB_OUTPUT

      - name: "üìä Cleanup Summary"
        id: cleanup-summary
        run: |
          echo "üìä Generating cleanup summary..."
          
          total_artifacts="${{ steps.artifact-analysis.outputs.total-artifacts }}"
          total_size="${{ steps.artifact-analysis.outputs.total-size-mb }}"
          cleanup_count="${{ steps.cleanup-strategy.outputs.cleanup-count }}"
          
          # Generate cleanup report
          cat > artifacts/cleanup/cleanup-summary.json << EOF
          {
            "timestamp": "$(date -Iseconds)",
            "before_cleanup": {
              "total_artifacts": $total_artifacts,
              "total_size_mb": $total_size
            },
            "cleanup_actions": {
              "artifacts_removed": $cleanup_count,
              "cleanup_strategies": [
                "Remove artifacts from failed runs (>7 days old)",
                "Remove duplicate artifacts (keep latest 3 per name)"
              ]
            },
            "recommendations": [
              "Implement automatic cleanup policies",
              "Use shorter retention periods for non-critical artifacts",
              "Regular cleanup scheduling (weekly)"
            ]
          }
          EOF
          
          echo "summary=Cleaned $cleanup_count artifacts, $total_size MB total size" >> $GITHUB_OUTPUT

      - name: Upload Cleanup Results
        uses: actions/upload-artifact@v4
        with:
          name: cleanup-results-${{ github.run_id }}
          path: artifacts/cleanup/
          retention-days: ${{ env.RETENTION_POLICY_DAYS }}

  # ============================================
  # STAGE 4: Performance Optimization
  # ============================================
  performance-optimization:
    name: Performance Optimization
    runs-on: ubuntu-latest
    timeout-minutes: 20
    needs: infrastructure-health
    if: github.event.inputs.action == 'performance-analysis' || github.event.inputs.action == 'health-check'
    outputs:
      optimization-score: ${{ steps.optimization-analysis.outputs.score }}
    steps:
      - name: Checkout Repository
        uses: actions/checkout@v4

      - name: "üöÄ Workflow Performance Analysis"
        id: performance-analysis
        run: |
          echo "üöÄ Analyzing workflow performance characteristics..."
          
          mkdir -p artifacts/performance
          
          # Analyze caching strategies
          cache_usage=0
          cache_strategies=()
          
          for workflow in .github/workflows/*.yml; do
            if [[ -f "$workflow" ]]; then
              workflow_name=$(basename "$workflow")
              
              # Check for cache usage
              if grep -q "uses: actions/cache" "$workflow"; then
                ((cache_usage++))
                cache_strategies+=("$workflow_name: uses actions/cache")
              fi
              
              # Check for setup action caching
              if grep -q "cache:" "$workflow"; then
                ((cache_usage++))
                cache_strategies+=("$workflow_name: setup action caching")
              fi
            fi
          done
          
          workflow_count="${{ needs.infrastructure-health.outputs.workflow-count }}"
          cache_percentage=$(( (cache_usage * 100) / workflow_count ))
          
          echo "Cache Analysis:"
          echo "  Workflows with caching: $cache_usage/$workflow_count ($cache_percentage%)"
          
          for strategy in "${cache_strategies[@]}"; do
            echo "  - $strategy"
          done

      - name: "‚ö° Parallelization Analysis"
        run: |
          echo "‚ö° Analyzing parallelization opportunities..."
          
          # Analyze job dependencies and parallelization
          total_parallel_jobs=0
          sequential_workflows=0
          
          for workflow in .github/workflows/*.yml; do
            if [[ -f "$workflow" ]]; then
              workflow_name=$(basename "$workflow")
              
              # Check for matrix strategies
              matrix_jobs=$(yq eval '[.jobs[] | select(.strategy.matrix)] | length' "$workflow" 2>/dev/null || echo "0")
              total_parallel_jobs=$((total_parallel_jobs + matrix_jobs))
              
              # Check for job dependencies (needs:)
              has_dependencies=$(yq eval '[.jobs[] | select(.needs)] | length' "$workflow" 2>/dev/null || echo "0")
              total_jobs=$(yq eval '.jobs | keys | length' "$workflow" 2>/dev/null || echo "0")
              
              if [[ $has_dependencies -eq $((total_jobs - 1)) ]]; then
                # Mostly sequential workflow
                ((sequential_workflows++))
              fi
              
              echo "  $workflow_name: $matrix_jobs matrix jobs, $has_dependencies dependencies, $total_jobs total jobs"
            fi
          done
          
          echo "Parallelization Analysis:"
          echo "  Total Matrix Jobs: $total_parallel_jobs"
          echo "  Sequential Workflows: $sequential_workflows"
          echo "  Parallelization Opportunities: $(( workflow_count - sequential_workflows ))"

      - name: "üîß Optimization Recommendations"
        id: optimization-analysis
        run: |
          echo "üîß Generating optimization recommendations..."
          
          # Calculate optimization score
          base_score=100
          workflow_count="${{ needs.infrastructure-health.outputs.workflow-count }}"
          
          # Deduct points for missing optimizations
          deductions=0
          
          # Check for missing concurrency controls
          missing_concurrency=$(find .github/workflows -name "*.yml" -exec grep -L "concurrency:" {} \; | wc -l)
          deductions=$((deductions + missing_concurrency * 5))
          
          # Check for missing timeout configurations
          missing_timeouts=$(find .github/workflows -name "*.yml" -exec grep -L "timeout-minutes:" {} \; | wc -l)
          deductions=$((deductions + missing_timeouts * 3))
          
          # Check for outdated action versions
          outdated_actions=$(grep -r "uses:" .github/workflows/ | grep -E "(v1|v2|@v[12])" | wc -l || echo "0")
          deductions=$((deductions + outdated_actions * 2))
          
          optimization_score=$((base_score - deductions))
          if [[ $optimization_score -lt 0 ]]; then
            optimization_score=0
          fi
          
          echo "Optimization Analysis:"
          echo "  Optimization Score: $optimization_score/100"
          echo "  Missing Concurrency Controls: $missing_concurrency"
          echo "  Missing Timeouts: $missing_timeouts"
          echo "  Outdated Actions: $outdated_actions"
          
          # Generate optimization report
          cat > artifacts/performance/optimization-report.json << EOF
          {
            "timestamp": "$(date -Iseconds)",
            "optimization_score": $optimization_score,
            "analysis": {
              "missing_concurrency_controls": $missing_concurrency,
              "missing_timeouts": $missing_timeouts,
              "outdated_actions": $outdated_actions
            },
            "recommendations": [
              "Add concurrency controls to all workflows",
              "Set appropriate timeout-minutes for all jobs",
              "Update actions to latest versions (v4+)",
              "Implement intelligent caching strategies",
              "Use matrix strategies for parallel execution",
              "Optimize artifact retention policies"
            ]
          }
          EOF
          
          echo "score=$optimization_score" >> $GITHUB_OUTPUT

      - name: Upload Performance Analysis
        uses: actions/upload-artifact@v4
        with:
          name: performance-analysis-${{ github.run_id }}
          path: artifacts/performance/
          retention-days: ${{ env.RETENTION_POLICY_DAYS }}

  # ============================================
  # STAGE 5: Infrastructure Report Generation
  # ============================================
  generate-infrastructure-report:
    name: Generate Infrastructure Report
    runs-on: ubuntu-latest
    timeout-minutes: 10
    needs: [infrastructure-health, security-infrastructure-audit, artifact-cache-management, performance-optimization]
    if: always()
    outputs:
      report-id: ${{ steps.report-generation.outputs.report-id }}
      overall-status: ${{ steps.final-assessment.outputs.status }}
    steps:
      - name: Checkout Repository
        uses: actions/checkout@v4

      - name: Download All Analysis Results
        uses: actions/download-artifact@v4
        continue-on-error: true
        with:
          pattern: "*-${{ github.run_id }}"
          path: analysis-results/
          merge-multiple: true

      - name: "üìã Comprehensive Infrastructure Report"
        id: report-generation
        run: |
          echo "üìã Generating comprehensive infrastructure report..."
          
          mkdir -p artifacts/infrastructure-report
          report_id="infrastructure-report-$(date +%Y%m%d-%H%M%S)"
          
          # Collect metrics
          health_score="${{ needs.infrastructure-health.outputs.health-score }}"
          workflow_count="${{ needs.infrastructure-health.outputs.workflow-count }}"
          security_score="${{ needs.security-infrastructure-audit.outputs.security-score }}"
          optimization_score="${{ needs.performance-optimization.outputs.optimization-score }}"
          
          # Calculate overall infrastructure health
          if [[ -n "$health_score" && -n "$security_score" && -n "$optimization_score" ]]; then
            overall_score=$(( (health_score + security_score + optimization_score) / 3 ))
          elif [[ -n "$health_score" ]]; then
            overall_score=$health_score
          else
            overall_score=50
          fi
          
          # Generate comprehensive report
          cat > artifacts/infrastructure-report/infrastructure-report.md << 'EOF'
          # CI/CD Infrastructure Health Report
          
          **Report ID:** ${{ steps.report-generation.outputs.report-id }}  
          **Generated:** $(date -Iseconds)  
          **Repository:** ${{ github.repository }}  
          **Branch:** ${{ github.ref_name }}
          
          ## Executive Summary
          
          This report provides a comprehensive analysis of the CI/CD infrastructure health, security posture, and performance characteristics.
          
          ### Overall Health Score: $overall_score/100
          
          | Component | Score | Status |
          |-----------|-------|--------|
          | Infrastructure Health | $health_score/100 | ${{ needs.infrastructure-health.outputs.health-score >= 80 && '‚úÖ GOOD' || needs.infrastructure-health.outputs.health-score >= 60 && '‚ö†Ô∏è FAIR' || '‚ùå POOR' }} |
          | Security Posture | ${security_score:-'N/A'}/100 | ${{ needs.security-infrastructure-audit.outputs.security-score >= 80 && '‚úÖ SECURE' || needs.security-infrastructure-audit.outputs.security-score >= 60 && '‚ö†Ô∏è MODERATE' || '‚ùå INSECURE' }} |
          | Performance Optimization | ${optimization_score:-'N/A'}/100 | ${{ needs.performance-optimization.outputs.optimization-score >= 80 && '‚úÖ OPTIMIZED' || needs.performance-optimization.outputs.optimization-score >= 60 && '‚ö†Ô∏è MODERATE' || '‚ùå NEEDS WORK' }} |
          
          ## Infrastructure Overview
          
          - **Total Workflows:** $workflow_count
          - **Health Issues:** ${{ needs.infrastructure-health.outputs.issues-found }}
          - **Security Vulnerabilities:** ${{ needs.security-infrastructure-audit.outputs.vulnerabilities }}
          - **Artifacts Cleaned:** ${{ needs.artifact-cache-management.outputs.cleanup-summary }}
          
          ## Key Findings
          
          ### Strengths
          - Modern GitHub Actions workflow structure
          - Comprehensive security scanning implementation
          - Advanced caching and optimization strategies
          - Robust artifact management policies
          
          ### Areas for Improvement
          ${{ needs.infrastructure-health.outputs.health-score < 80 && '- Workflow health issues need attention' || '' }}
          ${{ needs.security-infrastructure-audit.outputs.security-score < 80 && '- Security vulnerabilities require remediation' || '' }}
          ${{ needs.performance-optimization.outputs.optimization-score < 80 && '- Performance optimizations needed' || '' }}
          
          ## Recommendations
          
          ### Immediate Actions (High Priority)
          1. Update outdated action versions to v4+
          2. Add timeout configurations to all jobs
          3. Implement concurrency controls
          4. Review and remediate security findings
          
          ### Short-term Improvements (Medium Priority)
          1. Optimize caching strategies
          2. Implement artifact retention policies
          3. Add performance monitoring
          4. Enhance security scanning coverage
          
          ### Long-term Enhancements (Low Priority)
          1. Implement workflow performance benchmarking
          2. Add automated infrastructure health monitoring
          3. Create self-healing workflow capabilities
          4. Develop comprehensive CI/CD metrics dashboard
          
          ## Infrastructure Architecture
          
          The current CI/CD infrastructure follows a multi-stage approach:
          
          1. **Pre-flight Checks** - Fast syntax and security validation
          2. **Parallel Quality Gates** - Code quality and testing in parallel
          3. **Security Validation** - Comprehensive security scanning
          4. **Build & Package** - Artifact generation with SBOM
          5. **Deployment Gates** - Final validation before deployment
          
          ## Monitoring & Alerting
          
          Current monitoring includes:
          - Workflow execution time tracking
          - Artifact usage monitoring  
          - Security vulnerability detection
          - Performance regression analysis
          
          ## Conclusion
          
          ${{ overall_score >= 85 && 'The CI/CD infrastructure is in excellent condition with minimal improvements needed.' || overall_score >= 70 && 'The infrastructure is generally healthy but would benefit from addressing identified issues.' || 'The infrastructure requires significant attention to improve reliability and security.' }}
          
          **Next Review Date:** $(date -d '+30 days' --iso-8601)
          
          ---
          *Generated by CI/CD Infrastructure Manager v${{ env.INFRASTRUCTURE_VERSION }}*
          EOF
          
          echo "report-id=$report_id" >> $GITHUB_OUTPUT

      - name: "üéØ Final Assessment"
        id: final-assessment
        run: |
          echo "üéØ Performing final infrastructure assessment..."
          
          health_score="${{ needs.infrastructure-health.outputs.health-score }}"
          security_score="${{ needs.security-infrastructure-audit.outputs.security-score }}"
          optimization_score="${{ needs.performance-optimization.outputs.optimization-score }}"
          
          # Determine overall status
          if [[ $health_score -ge 80 && ${security_score:-80} -ge 80 && ${optimization_score:-80} -ge 80 ]]; then
            overall_status="excellent"
            echo "‚úÖ INFRASTRUCTURE STATUS: EXCELLENT"
          elif [[ $health_score -ge 70 && ${security_score:-70} -ge 70 && ${optimization_score:-70} -ge 70 ]]; then
            overall_status="good"
            echo "‚úÖ INFRASTRUCTURE STATUS: GOOD"
          elif [[ $health_score -ge 60 && ${security_score:-60} -ge 60 && ${optimization_score:-60} -ge 60 ]]; then
            overall_status="fair"
            echo "‚ö†Ô∏è INFRASTRUCTURE STATUS: FAIR"
          else
            overall_status="needs-improvement"
            echo "‚ùå INFRASTRUCTURE STATUS: NEEDS IMPROVEMENT"
          fi
          
          echo "status=$overall_status" >> $GITHUB_OUTPUT

      - name: Upload Infrastructure Report
        uses: actions/upload-artifact@v4
        with:
          name: infrastructure-report-${{ github.run_id }}
          path: artifacts/infrastructure-report/
          retention-days: ${{ env.SECURITY_RETENTION_DAYS }}

      - name: Create Issue for Critical Findings
        if: steps.final-assessment.outputs.status == 'needs-improvement'
        uses: actions/github-script@v7
        with:
          script: |
            const { data: issues } = await github.rest.issues.listForRepo({
              owner: context.repo.owner,
              repo: context.repo.repo,
              labels: ['infrastructure', 'critical'],
              state: 'open'
            });
            
            const existingIssue = issues.find(issue => 
              issue.title.includes('Critical Infrastructure Issues')
            );
            
            const issueBody = `## Critical Infrastructure Issues Detected
            
            **Report ID:** ${{ steps.report-generation.outputs.report-id }}
            **Date:** ${new Date().toISOString()}
            
            ### Summary
            - Health Score: ${{ needs.infrastructure-health.outputs.health-score }}/100
            - Security Score: ${{ needs.security-infrastructure-audit.outputs.security-score }}/100  
            - Optimization Score: ${{ needs.performance-optimization.outputs.optimization-score }}/100
            
            ### Critical Issues
            - Health Issues Found: ${{ needs.infrastructure-health.outputs.issues-found }}
            - Security Vulnerabilities: ${{ needs.security-infrastructure-audit.outputs.vulnerabilities }}
            
            ### Immediate Actions Required
            1. Review infrastructure health report
            2. Address security vulnerabilities
            3. Implement performance optimizations
            4. Update workflow configurations
            
            **Workflow Run:** ${{ github.server_url }}/${{ github.repository }}/actions/runs/${{ github.run_id }}
            
            /cc @${{ github.actor }}`;
            
            if (existingIssue) {
              await github.rest.issues.createComment({
                issue_number: existingIssue.number,
                owner: context.repo.owner,
                repo: context.repo.repo,
                body: issueBody
              });
            } else {
              await github.rest.issues.create({
                owner: context.repo.owner,
                repo: context.repo.repo,
                title: 'Critical Infrastructure Issues Detected',
                body: issueBody,
                labels: ['infrastructure', 'critical', 'needs-attention']
              });
            }